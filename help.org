#+STARTUP: showeverything
#+PROPERTY: results output silent
* README

HELP Enables Literate Programming.

Setup:

1) [[http://orgmode.org/][Pull Org-Mode]] to =~/src/=.
   1) If necessary: [[http://orgmode.org/worg/org-hacks.html][Generating autoloads and Compiling Org without make]]
2) [[https://github.com/jwiegley/use-package][Pull Use-Package]] to =~/src/=.
3) Create a folder for support libraries exporting it's location in a variable
   named =EELIB=.
   1) Install [[http://ditaa.sourceforge.net/][DITAA]] renaming the JAR to =ditaa.jar=.
   2) Install [[http://plantuml.com/][PlantUML]] renaming the JAR to =plantuml.jar=.
4) Install supporting systems adding their exectuables to the =PATH=.
   1) [[https://www.oracle.com/java/index.html][Oracle Java]].
5) Link.
   - The Eshell directory to HELP's.
     - =ln -s ~/src/help/eshell/ ~/.emacs.d/eshell=
   - The Init file to HELP's.
     - =ln -s ~/src/help/.emacs.el ~/.emacs.el=

* Style Guide

- Code Block
  - Tell the story in speech, and then in code.
  - Consider it another paragraph and indent appropriately.
  - When contained within a list.
    - Indent begin/end blocks with list content; this makes it clear to Org-Mode
      to export it as a code block.
    - Source code is indented according to existing settings. This system keeps
      it left-aligned, saving space.
- Content
  - When importing, update to conform with Style-Guide.
- Dictionary
  - Exemple Complet Minimal (ECM) :: The minimal complete example of expected
    versus actual behavior. Comes from the [[http://orgmode.org/worg/org-faq.html][Org-Mode]] community.
  - Key-Bind :: A verb. The act of creating a Key Binding.
  - Literate Programming (LP) :: As Knuth intended.
  - Out of the Box (OOTB) :: The default configuration of something.
  - Sysop :: A proper noun. The System-Operator. The human operating this EMACS
    based Org-Mode enabled literate programming system. The reader.
  - Tangle :: A verb. Assemble a document for consumption by another program or
    machine.
  - Weave :: A verb. Prepare a document for consumption by a human.
- File/Package Loading
  - Load every one with ~use-package~ whether it came with EMACS OOTB or ELPA.
    - ~ensure~ tells the reader which one it came from.
- Formatting
  - Code Snippet.
    - Programming language expressions.
    - Use ~code style~.
  - Non-Code Snippet.
    - Program names, file types
    - Use =verbatim= style
  - Package.
    - Same as Headline.
    - Dashes separate definition.
    - Acronyms are all upper case to distinguish from words for example "GNU"
      vs "Gnu".
- Headline.
  - Capitalize nouns, verbs, and adjectives.
  - Don't capitalize conjunctions unless they are starting the definition.
  - Sell this "chapter" to the reader.
  - Some headlines will be empty and significant; keep them.
    - Some modes don't require any configuration. The headline still needs to be
      present to remind Sysop to keep it in her cognitive landscape.
    - Configure other properties and modes taking it into account.
    - Pros:
      - For example:
        - Every language under Hacking should show up in
          ~org-babel-load-languages~.
      - The Prog*-Mode system configuration can result in Headlines that don't
        need any configuration. The Headline still communicates the mode's
        value to Sysop even if it doesn't configure EMACS.
    - Cons:
      - Gives reader impression that modes are configured and ready to use.
  - It is important to include headlines that are empty and that you may not
    even end up keeping. You need them to help you explore the cognitive
    landscape with them present. In this one case, premature optimization is
    /not/ the root of all evil.
  - Sometimes headlines might better be:
    - List items.
    - Stand-alone bold'ed text without punctuation.
- Hyperlink.
  - External.
    - Exclude those easily found with a search-engine unless you are willing to
      verify their existence frequently.
    - Include when they make the task at hand immensely easier.
  - Internal.
    - Heading artifacts can be referenced so the need here is minimal to
      non-existent.
- Literate Programming.
  - Comments.
    - Exclude from tangle-blocks and rely on source-block for traceability.
  - Noweb-Ref.
    - Same as Headline.
    - Replace spaces with dashes.
    - Probably the Heading name.
    - Keep depth shallow
- Maintenance.
  - Frequently check spelling, grammar, and weasel-words.
- Plain List.
  - End single sentences with a period.
- Programming Language.
  - Emacs-Lisp.
    - Use ~t~ for ~true~.
    - Almost always use ~defun~ instead of ~advice-add~.
      - Functions are more normal and predictable.
      - Advice can subtly break without you noticing.
    - Paramemter.
      - ~nil~ for =FALSE=.
      - ~t~ for =TRUE=.
      - ~n~ for numerical values.
    - Try never to advise functions.
    - Never ~custom-set-variables~.
  - Always use relative file paths.
- Tangling.
  - When ordering matters, rely on block-reuse to enforce correct generation.
- Voice.
  - Provide answers; do not pose questions or observations.
  - Simple and detailed.
  - Pleasant conversation style.
  - Audience is Sysop; the author included.
- Word Choice.
  - Use Arabic numerals.
  - Instead of writing "tells EMACS", communicate the result.
  - "EMACS" refers to this software.
  - "This system" refers to this configuration of EMACS.

* Webs We Weave

** Org-Mode Exemple Complet Minimal
   :PROPERTIES:
   :noweb-ref: Org-Mode-ECM-Tangle-Block
   :tangle:  "./.org-mode-ecm.emacs.el"
   :comments: no
   :END:

Configure EMACS to easily provide ECMs.

Sysop is likely to use this often.

Start EMACS with this command:

=open /Applications/Emacs.app --args --quick --load ~/src/help/.org-mode-ecm.emacs.el=

#+BEGIN_SRC emacs-lisp
«Principle-of-Least-Astonishment»
«Org-Mode-ECM»
#+END_SRC

#+NAME:

** The Whole Enchilada
   :PROPERTIES:
   :tangle:  "./.emacs.el"
   :comments: no
   :END:

Configure EMACS to do everything provided by this document.

Sysop is likely to use this hourly.

Start EMACS with this command:

#+BEGIN_SRC emacs-lisp
«Org-Mode-ECM-Tangle-Block»
«Org-Mode-Helper-Functions»
«Org-Mode-Tangle»
«Org-Mode-Execute»
«Org-Mode-Weave»
«Watch-What-You-Eat»
«Special-Operating-Procedure»
«Standard-Operating-Procedure»
«Hacking-Prog*-Mode»
«Hacking-Emacs-Lisp»
«Hacking-Org-Mode»
«Hacking-YASnippet»
«Hacking-Publishing-TeX»
«Hacking-Artist»
«Hacking-DITAA»
«Hacking-PlantUML»
«Quiet-and-Pleasant-Appearance»
«Piano-Lessons»
#+END_SRC

=open /Applications/Emacs.app=

** Eshell

#+BEGIN_SRC sh :tangle "./eshell/alias" :comments no :eval no
alias clear recenter 0
alias d 'dired $1'
alias ff find-file $1
alias gb git branch $*
alias gpom git push origin master
alias gst git status
alias la ls -lha $*
alias ll ls -lh $*
#+END_SRC

* Literate Programming

This system enables you to perform 3 Literate Document activities. These
activities combine to provide a rich Literate Programming environment. Their
configuration is defined with more granularity here to make sense of how the
system is configured, where, and how it works. These activities are not
performed interactively by the user. They are automatic operations that occur
as a result of the configuration of the document itself.

The following is the guide for the default configuration of this system and how
it behaves.

Key:

- Columns
  - S :: Source document modified?
  - W :: Destination weaved-document modified?
  - T :: Destination tangled-document modified?
  - E :: Evaluation occurred?

| Activity   | S | W | T | E |
|------------+---+---+---+---|
| Tangling   | F | F | T | F |
| Evaluating | T | F | F | T |
| Exporting  | F | T | F | F |

They are separate and distinct operations and are defined as such.

The last logical action is the activity of "Programming". It is a combination of
three 3 activities listed above combined with the configuration of EMACS to do
so. This is an interactive activity performed Sysop. The results of Sysop's
activities are contained within the document. Those contents are input for the
activities here.

** Org-Mode Exemple Complet Minimal
   :PROPERTIES:
   :noweb-ref: Org-Mode-ECM
   :END:

A stable version of Org-Mode is provided OOTB. It's release cycle is tied to
EMACS release cycle. To get hot-fixes, cutting edge features, and easy patch
creation though, you need to use the version from Git.

The [[http://orgmode.org/manual/Installation.html][directions]] of how to run Org-Mode from Git are detailed and clear. The only
thing worth mentioning again is that in order to use *any* version of Org-Mode
other than the one that comes OOTB you *must* load Org-Mode *before* anything else
in your initialization file. This can be surprisingly easy to do! When you get
unexpected Org-Mode behavior be sure to stop and investigate ~org-version~ and
decide whether or not it is what you expect and prepare an ECM if necessary.

Add the Org-Mode core distribution the load path.

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/src/org-mode/lisp")
#+END_SRC

Add the Org-Mode-Contributions distribution to the load path. The contributions
are critical to and inseparable from the core distribution.

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/src/org-mode/contrib/lisp")
#+END_SRC

This system allows for single-character alphabetical bullet lists. For Org-Mode
to provide that, the following property must exist before Org-Mode is even
loaded. This configuration must occur here. *Never* remove this from a submitted
ECM.

#+BEGIN_SRC emacs-lisp
(setq org-list-allow-alphabetical t)
#+END_SRC

Load Org-Mode.

#+BEGIN_SRC emacs-lisp
(require 'org)
#+END_SRC

Org-Mode already uses the guillemot for demarcating noweb references, but it
does it using the work-around of just using less-than and greater-than
characters twice. That is fine. Because EMACS supports Unicode just fine though,
configure Org-Mode to use the real symbol. Another option would be to configure
Pretty-Mode. This is in the ECM section because so that I can verify behavior of
my code.

#+BEGIN_SRC emacs-lisp
(setq org-babel-noweb-wrap-start "«")
(setq org-babel-noweb-wrap-end "»")
#+END_SRC

** Helper Functions
   :PROPERTIES:
   :noweb-ref: Org-Mode-Helper-Functions
   :END:

#+BEGIN_SRC emacs-lisp
(defun help/set-org-babel-default-header-args (property value)
  "Easily set system header arguments in org mode.

PROPERTY is the system-wide value that you would like to modify.

VALUE is the new value you wish to store.

Attribution: URL `http://orgmode.org/manual/System_002dwide-header-arguments.html#System_002dwide-header-arguments'"
  (setq org-babel-default-header-args
        (cons (cons property value)
              (assq-delete-all property org-babel-default-header-args))))

(defun help/set-org-babel-default-inline-header-args (property value)
  "See `help/set-org-babel-default-header-args'; same but for inline header args."
  (setq org-babel-default-inline-header-args
        (cons (cons property value)
              (assq-delete-all property org-babel-default-inline-header-args))))

(defun help/comment-or-uncomment ()
  "Comment or uncomment the current line or selection."
  (interactive)
  (cond ((not mark-active) (comment-or-uncomment-region (line-beginning-position)
                                                      (line-end-position)))
        ((< (point) (mark)) (comment-or-uncomment-region (point) (mark)))
        (t (comment-or-uncomment-region (mark) (point)))))

(defun help/save-all-file-buffers (&rest ls)
  "Saves every buffer associated with a file

LS captures arguments when this is used as before advice."
  (interactive)
  (dolist (buf (buffer-list))
    (with-current-buffer buf
      (when (and (buffer-file-name) (buffer-modified-p))
        (save-buffer)))))

(defun describe-thing-in-popup ()
  "Attribution: URL `http://blog.jenkster.com/2013/12/popup-help-in-emacs-lisp.html'."
  (interactive)
  (let* ((thing (symbol-at-point))
         (help-xref-following t)
         (description (with-temp-buffer
                        (help-mode)
                        (help-xref-interned thing)
                        (buffer-string))))
    (popup-tip description
               :point (point)
               :around t
               :height 30
               :scroll-bar t
               :margin t)))

(defun help/kill-other-buffers ()
  "Kill all other buffers."
  (interactive)
  (mapc 'kill-buffer (delq (current-buffer) (buffer-list))))

(defvar help/delete-trailing-whitespace-p t
  "Should trailing whitespace be removed?")

(defun help/delete-trailing-whitespace ()
  "Delete trailing whitespace for everything but the current line.

If `help/delete-trailing-whitespace-p' is non-nil, then delete the whitespace.
This is useful for fringe cases where trailing whitespace is important."
  (interactive)
  (when help/delete-trailing-whitespace-p
    (let ((first-part-start (point-min))
          (first-part-end (point-at-bol))
          (second-part-start (point-at-eol))
          (second-part-end (point-max)))
      (delete-trailing-whitespace first-part-start first-part-end)
      (delete-trailing-whitespace second-part-start second-part-end))))

(defun help/insert-timestamp ()
  "Produces and inserts a full ISO 8601 format timestamp."
  (interactive)
  (insert (format-time-string "%Y-%m-%dT%T%z")))

(defun help/insert-timestamp* ()
  "Produces and inserts a near-full ISO 8601 format timestamp."
  (interactive)
  (insert (format-time-string "%Y-%m-%dT%T")))

(defun help/insert-datestamp ()
  "Produces and inserts a partial ISO 8601 format timestamp."
  (interactive)
  (insert (format-time-string "%Y-%m-%d")))

(defun help/no-control-m ()
  "Aka dos2unix."
  (interactive)
  (let ((line (line-number-at-pos))
        (column (current-column)))
    (mark-whole-buffer)
    (replace-string "
          " "")
    (goto-line line)
    (move-to-column column)))

(defun help/indent-curly-block (&rest _ignored)
  "Open a new brace or bracket expression, with relevant newlines and indent. Src: https://github.com/Fuco1/smartparens/issues/80"
  (newline)
  (indent-according-to-mode)
  (forward-line -1)
  (indent-according-to-mode))

(defun beginning-of-line-dwim ()
  "Toggles between moving point to the first non-whitespace character, and
    the start of the line. Src: http://www.wilfred.me.uk/"
  (interactive)
  (let ((start-position (point)))
    ;; see if going to the beginning of the line changes our position
    (move-beginning-of-line nil)

    (when (= (point) start-position)
      ;; we're already at the beginning of the line, so go to the
      ;; first non-whitespace character
      (back-to-indentation))))

(defun help/lazy-new-open-line ()
  "Insert a new line without breaking the current line."
  (interactive)
  (beginning-of-line)
  (next-line)
  (newline)
  (previous-line))

(defun help/smart-open-line ()
  "Insert a new line, indent it, and move the cursor there.

This behavior is different then the typical function bound to return
which may be `open-line' or `newline-and-indent'. When you call with
the cursor between ^ and $, the contents of the line to the right of
it will be moved to the newly inserted line. This function will not
do that. The current line is left alone, a new line is inserted, indented,
and the cursor is moved there.

Attribution: URL `http://emacsredux.com/blog/2013/03/26/smarter-open-line/'"
  (interactive)
  (move-end-of-line nil)
  (newline-and-indent))

(defun help/insert-ellipsis ()
  "Insert an ellipsis into the current buffer."
  (interactive)
  (insert "…"))

(defun help/insert-noticeable-snip-comment-line ()
  "Insert a noticeable snip comment line (NSCL)."
  (interactive)
  (if (not (bolp))
      (message "I may only insert a NSCL at the beginning of a line.")
    (let ((ncl (make-string 70 ?✂)))
      (newline)
      (previous-line)
      (insert ncl)
      (comment-or-uncomment-region (line-beginning-position) (line-end-position)))))

(progn
  (defvar my-read-expression-map
    (let ((map (make-sparse-keymap)))
      (set-keymap-parent map read-expression-map)
      (define-key map [(control ?g)] #'minibuffer-keyboard-quit)
      (define-key map [up]   nil)
      (define-key map [down] nil)
      map))

  (defun my-read--expression (prompt &optional initial-contents)
    (let ((minibuffer-completing-symbol t))
      (minibuffer-with-setup-hook
          (lambda ()
            (emacs-lisp-mode)
            (use-local-map my-read-expression-map)
            (setq font-lock-mode t)
            (funcall font-lock-function 1))
        (read-from-minibuffer prompt initial-contents
                              my-read-expression-map nil
                              'read-expression-history)))))

(defun my-eval-expression (expression &optional arg)
  (interactive (list (read (my-read--expression ""))
                     current-prefix-arg))
  (if arg
      (insert (pp-to-string (eval expression lexical-binding)))
    (pp-display-expression (eval expression lexical-binding)
                           "*Pp Eval Output*")))

(defun help/util-ielm ()
  "HELP buffer setup for ielm.

Creates enough space for one other permanent buffer beneath it."
  (interactive)
  (split-window-below -20)
  (help/safb-other-window)
  (ielm)
  (set-window-dedicated-p (selected-window) t))

(defun help/util-eshell ()
  "HELP buffer setup for eshell.

Depends upon `help/util-ielm' being run first."
  (interactive)
  (split-window-below -10)
  (help/safb-other-window)
  (eshell)
  (set-window-dedicated-p (selected-window) t))

(defvar help/util-state nil "Track whether the util buffers are displayed or not.")

(defun help/util-state-toggle ()
  "Toggle the util state."
  (interactive)
  (setq help/util-state (not help/util-state)))

(defun help/util-start ()
  "Perhaps utility buffers."
  (interactive)
  (help/util-ielm)
  (help/util-eshell)
  (help/util-state-toggle))

(defun help/util-stop ()
  "Remove personal utility buffers."
  (interactive)
  (if (get-buffer "*ielm*") (kill-buffer "*ielm*"))
  (if (get-buffer "*eshell*") (kill-buffer "*eshell*"))
  (help/util-state-toggle))

(defun help/ielm-auto-complete ()
  "Enables `auto-complete' support in \\[ielm].

Attribution: URL `http://www.masteringemacs.org/articles/2010/11/29/evaluating-elisp-emacs/'"
  (setq ac-sources '(ac-source-functions
                     ac-source-variables
                     ac-source-features
                     ac-source-symbols
                     ac-source-words-in-same-mode-buffers))
  (add-to-list 'ac-modes 'inferior-emacs-lisp-mode)
  (auto-complete-mode 1))

(defun help/uuid-string ()
  "Insert a string form of a UUID."
  (interactive)
  (insert (uuid-to-stringy (uuid-create))))

(defun endless/sharp ()
  "Insert #' unless in a string or comment.

SRC: URL `http://endlessparentheses.com/get-in-the-habit-of-using-sharp-quote.html?source=rss'"
  (interactive)
  (call-interactively #'self-insert-command)
  (let ((ppss (syntax-ppss)))
    (unless (or (elt ppss 3)
                (elt ppss 4))
      (insert "'"))))

(defun help/chs ()
  "Insert opening \"cut here start\" snippet."
  (interactive)
  (insert "--8<---------------cut here---------------start------------->8---"))

(defun help/che ()
  "Insert closing \"cut here end\" snippet."
  (interactive)
  (insert "--8<---------------cut here---------------end--------------->8---"))

(defmacro help/measure-time (&rest body)
  "Measure the time it takes to evaluate BODY.

Attribution Nikolaj Schumacher: URL `https://lists.gnu.org/archive/html/help-gnu-emacs/2008-06/msg00087.html'"
  `(let ((time (current-time)))
     ,@body
     (message "%.06f" (float-time (time-since time)))))

(defun help/create-non-existent-directory ()
  "Attribution URL: `https://iqbalansari.github.io/blog/2014/12/07/automatically-create-parent-directories-on-visiting-a-new-file-in-emacs/'"
  (let ((parent-directory (file-name-directory buffer-file-name)))
    (when (and (not (file-exists-p parent-directory))
               (y-or-n-p (format "Directory `%s' does not exist. Create it?" parent-directory)))
      (make-directory parent-directory t))))

(defun help/occur-dwim ()
  "Call `occur' with a mostly sane default.

Attribution Oleh Krehel (abo-abo): URL `http://oremacs.com/2015/01/26/occur-dwim/'"
  (interactive)
  (push (if (region-active-p)
            (buffer-substring-no-properties
             (region-beginning)
             (region-end))
          (let ((sym (thing-at-point 'symbol)))
            (when (stringp sym)
              (regexp-quote sym))))
        regexp-history)
  (call-interactively 'occur))

(defun help/util-cycle ()
  "Display or hide the utility buffers."
  (interactive)
  (if help/util-state
      (help/util-stop)
    (help/util-start)))

(defun sacha/unfill-paragraph (&optional region)
  "Takes a multi-line paragraph and makes it into a single line of text.

ATTRIBUTION: SRC https://github.com/sachac/.emacs.d/blob/gh-pages/Sacha.org#unfill-paragraph"
  (interactive (progn
                 (barf-if-buffer-read-only)
                 (list t)))
  (let ((fill-column (point-max)))
    (fill-paragraph nil region)))
#+END_SRC

** Tangling
   :PROPERTIES:
   :noweb-ref: Org-Mode-Tangle
   :END:

There is a way to disable property inheritance that speeds up tangling a lot.
This is only for user-defined properties; *not* Org-Mode properties.

The problem is that you lose property inheritance which is unacceptable. Never,
never allow that. Its inconsistent with how Org-Mode works.

#+BEGIN_SRC emacs-lisp
(setq org-babel-use-quick-and-dirty-noweb-expansion nil)
#+END_SRC

*** Comments

Provide as much information as possible in the tangled artifact about the
origin artifact.

#+BEGIN_SRC emacs-lisp
(help/set-org-babel-default-header-args :comments "noweb")
#+END_SRC

*** Padline

~org-babel-tangle-jump-to-org~ requires padded lines. This configuration could
arguably appear in the "Programming" heading because it impacts operation. It
lives here because it *must* occur as part of the Tangling activity so that it
can be used in the Programming activity.

#+BEGIN_SRC emacs-lisp
(help/set-org-babel-default-header-args :padline "yes")
#+END_SRC

*** Noweb

Expand noweb references in source-blocks before:

| Activity   | Expand |
|------------+--------|
| Tangling   | T      |
| Evaluating | T      |
| Exporting  | F      |

This embraces the notion that you are telling the right thing to the
computer and the right thing to the human. By the time you get to exporting, you
ought to refer to the generated document.

#+BEGIN_SRC emacs-lisp
(help/set-org-babel-default-header-args :noweb "no-export")
#+END_SRC

** Evaluating
   :PROPERTIES:
   :noweb-ref: Org-Mode-Execute
   :END:

Org-Mode may evaluate all of the listed languages.

#+BEGIN_SRC emacs-lisp
(org-babel-do-load-languages
 'org-babel-load-languages
 '((calc . t)
   (css . t)
   (dot . t)
   (ditaa . t)
   (emacs-lisp . t)
   (js . t)
   (latex . t)
   (lilypond . t)
   (makefile . t)
   (org . t)
   (perl . t)
   (python . t)
   (plantuml . t)
   (R . t)
   (scheme . t)
   (sh . t)
   (sql . t)))
#+END_SRC

*** Eval

Never evaluate source-blocks or in-line-source-blocks on export.

#+BEGIN_SRC emacs-lisp
(help/set-org-babel-default-header-args :eval "never-export")
(help/set-org-babel-default-inline-header-args :eval "never-export")
#+END_SRC

Be sure to never evaluate in-line-source-blocks on export.

#+BEGIN_SRC emacs-lisp
(setq org-export-babel-evaluate nil)
#+END_SRC

*** Results

This system stores the results of evaluation in the source document. It believes
that the results are critical to the research.

Always display results like you would seem them in a REPL. For source-blocks
this means an =output= display and for in-line-source-blocks it means a =value=
display.

Replace theme each time you evaluate the block.

#+BEGIN_SRC emacs-lisp
(help/set-org-babel-default-header-args :results "output replace")
(help/set-org-babel-default-inline-header-args :results "value replace")
#+END_SRC

** Weaving
   :PROPERTIES:
   :noweb-ref: Org-Mode-Weave
   :END:

Load Htmlize for HTML export. Use it. Use in-line CSS.

#+BEGIN_SRC emacs-lisp
(require 'htmlize)
(setq org-html-htmlize-output-type htmlize-output-type)
(setq htmlize-output-type 'inline-css)
#+END_SRC

Load Beamer for creating reports.

#+BEGIN_SRC emacs-lisp
(require 'ox-beamer)
#+END_SRC

Load Markdown export for system compatibility.

#+BEGIN_SRC emacs-lisp
(require 'ox-md)
#+END_SRC

Make sure that exported files are Unicode UTF-8.
#+BEGIN_SRC emacs-lisp
(setq org-export-coding-system 'utf-8)
#+END_SRC

Do not preserve line-breaks when exporting instead let the destination
format handle it as it sees fit. This doesn't work like I had expected and makes
me wonder what I am confused about here. When I export to HTML text containing
linebreaks no longer has linebreaks. This is what I expect. When I export that
same text to a buffer though, the line breaks are included. Currently I use
=sacha/unfill-paragraph= on that code.
#+BEGIN_SRC emacs-lisp
(setq org-export-preserve-breaks nil)
#+END_SRC

When exporting anything, do not insert the exported content into the kill ring.
#+BEGIN_SRC emacs-lisp
(setq org-export-copy-to-kill-ring nil)
#+END_SRC

By default I never want a table of contents generated. It is so easy to enable
it with a property, it will be fine to turn it off.

#+BEGIN_SRC emacs-lisp
(setq org-export-with-toc nil)
#+END_SRC

On export, maintain the literal spacing as found in the source block. Obviously
this is important for make-files. It is really important everywhere because
anything else would violate the law of least surprise.

#+BEGIN_SRC emacs-lisp
(setq org-src-preserve-indentation t)
#+END_SRC

*** Exports

Always share source blocks and their results. Whether or not to generate a
result for a particular source block is configured per-block. If you don't want
to share a result for a source block then disable storage of results on that
block.

#+BEGIN_SRC emacs-lisp
(help/set-org-babel-default-header-args :exports "both")
#+END_SRC


*** KOMA-Script

I enjoy writing letters. I enjoy reading letters. LaTeX produces letters that
are easy to print and read. Org provides a [[http://orgmode.org/worg/exporters/koma-letter-export.html][KOMA Script exporter]] for [[https://www.ctan.org/pkg/koma-script?lang%3Den][KOMA-script]].
The Org documentation mentions that the user should read the [[http://orgmode.org/cgit.cgi/org-mode.git/plain/contrib/lisp/ox-koma-letter.el][ox-koma-letter.el]]
header documentation.

The [[https://www.ctan.org/pkg/babel?lang%3Den][babel]] packages is mentioned in the Org documentation. The package
documentation explains that it should be used with LaTeX, but not XeTeX. Some
time ago I decided to stick with LaTeX.

Load the KOMA exporter.

#+BEGIN_SRC emacs-lisp
(eval-after-load 'ox '(require 'ox-koma-letter))
#+END_SRC

- Understanding KOMA and how to use it
  - There are 4 ways to set letter metadata, listed "from the most specific to
    the most general" (not sure exactly what this statement means, and the conclusion of my notes tries to make sense of what is really going on here and what is the best way to do things)
    - Org option lines (ORG)
    - Separate Org latex classes (LTX)
    - Emacs Lisp variables (LISP)
    - Letter Class Option files (LCO)
- Notes and thoughts on the ways to use it
  - LTX
    - By following the setup directions, you do this, creating "my-letter" class
    - Familiar and easy if you already know LaTeX
      - At some point in your workflow, you *must* define a class to use, anyway
    - Very easy to do, just define the class template and set =org-koma-letter-default-class=
  - ORG
    - Simple way that makes it very easy to just focus on the document content
    - This metadata takes highest priority in the workflow
      - So you should set your typical defaults in LISP or LCO and customize it
        here. This is exactly what I wanted to know.
      - This lets you do your tweaking in each unique file while relying on the
        most common defaults defined elsewhere
  - LISP
    - Very familiar style of configuring things
  - LCO
    - LCO == Letter Class Option files
    - LCO files are TeX
    - They are included in the generated TeX source code from the letter
    - Gives *full* access to KOMA-Script
      - Big deal, because not everything is exposed through ORG or LISP
      - Also gives full access to any and all TeX and LaTeX code
    - LCO files are a KOMA-Script thing, so they are a LaTeX thing
    -
      #+begin_quote
      Letter metadata set in LCO files overwrites letter metadata set in Emacs
      variables but not letter metadata set in the Org file.
      #+end_quote
    - When you include multiple LCO files, they are evaluated LIFO. Properties
      are set as they first appear, and are not set again. Say you include
      "MyGeneralStuffForAnyLetter.lco" and then include
      "MyStuffSpecificToThisLetter.lco". The specific stuff will get set first.
      Then general stuff will get set last.
      - Surely there is a better way to phrase this. I will work on that.
- Recommendations
  - What is the easiest way to start using KOMA-Script based on what you know
    today?
  - If you don't know any of the approaches
    - Then choose between learning LaTeX and Org
  - If you only know LaTeX
    - Then you will use the LTX/LCO metadata approach
  - If you only know ORG
    - Then you will use the ORG metadata approach
  - If you only know ORG and LISP
    - Then you will use the LISP approach for general metadata and the ORG
      approach specific metadata
  - If you know LTX/LCO, ORG, and LISP
    - Then you have total flexibility
    - The fact is that
      - ORG settings always trump LTX/LCO and LISP
      - LISP settings are a subset of all of the settings available in
        KOMA-Script, so you will always have to fall back to LTX/LCO if you want
        to use unexposed features
      - LCO files are just plain old LaTeX, which you already know
    - So the best thing to do
      - Is to use ORG for letter-specific settings
      - And LTX for general settings
      - Everything is a lot simpler this way because
        - One less metadata approach to keep track of
        - All KOMA-Script features are present
        - Need to learn details of KOMA-Script package anyway

Configure the default class.

[[https://tex.stackexchange.com/questions/102922/how-can-i-get-us-letter-output-from-koma-scripts-scrlttr2-class][This]] post explains how to default the US letter size. That is the likely default
for my printed correspondence.

#+BEGIN_SRC emacs-lisp
(eval-after-load 'ox-koma-letter
  '(progn
     (add-to-list 'org-latex-classes
                  '("my-letter"
                    "\\documentclass[paper=letter, pagesize, fontsize=10pt, parskip]{scrlttr2}
\\usepackage[english]{babel}
\\usepackage[osf]{mathpazo}"))

     (setq org-koma-letter-default-class "my-letter")))
#+END_SRC

There are two formats for the letters: [[http://orgmode.org/w/?p%3Dworg.git%3Ba%3Dblob%3Bf%3Dexporters/koma-letter-new-example.org%3Bh%3D180a9a0e10dd8f7483a67946daf36732c316f821%3Bhb%3D180a9a0e10dd8f7483a67946daf36732c316f821][heading-based]] and [[http://orgmode.org/w/?p%3Dworg.git%3Ba%3Dblob%3Bf%3Dexporters/koma-letter-example.org%3Bh%3De21b8b00c3e895be9dd573d02ea84b08796296a3%3Bhb%3De21b8b00c3e895be9dd573d02ea84b08796296a3][property-based]].

Set up my default LCO files.

#+BEGIN_SRC emacs-lisp
(setq org-koma-letter-class-option-file "UScommercial9 KomaDefault")
#+END_SRC

* Piano Lessons
   :PROPERTIES:
   :noweb-ref: Piano-Lessons
   :END:

** A Fine Cup of EMACS

Every EMACS user ought to have a [[http://shop.fsf.org/product/gnu-emacs-reference-mugs/][Emacs Reference Mug]] at their desk. The mug
invites other users to ask questions. Give the mug as a gift to every user you
know who would benefit from learning EMACS. The mug reminds us all that EMACS is
the perfect configuration of EMACS. It is available on every machine. When you
break your system, you can always fall back to the good and reliable default
EMACS configuration to get your system up and running again. The OOTB
configuration of EMACS is one of the most important system configurations that
you will every find. That is why it is important never to ruin it.

This system wants to maximize accessibility for new users. It wants anyone to be
able to download and use it without surprises. It wants the mug to serve as a
fine reference for anyone to use. It wants to keep things simple and familiar so
that anyone who has learned EMACS OOTB can use it pleasantly and productively.
These goals are essential to configuring the keyboard for this system. This
system will always respect the POLA.

** A Keyboard on Every Desk

The configuration of the keyboard on an EMACS system can completely change the
experience. No keyboard makes it impossible. A Kinesis Ergo makes it feel
really good. Soft keys make it feel soft; hard keys make it feel faster. The
[[http://xahlee.info/kbd/dvorak_and_all_keyboard_layouts.html][layout of letters]] is claimed to make you "more productive" using statistics.
You may even study the statistics of your own writing and choose a layout
optimized for you. The ways to configure your keyboard are limitless because
everyone is unique. How to get the best configuration tips for your system? Do
what works for everyone.

Choose a keyboard that will satisfy 80% of EMACS users using 80% of the
keyboards out there. Make this system easy to use on any one of those keyboards.
Make this system easy to use in English. Make this system easy to use with
average hand strength using two hands. These goals are essential to configuring
the keyboard for this system.

** A Display with Every Keyboard

Every system requires an output. You have two options. The first is a terminal
that only displays characters. The second is a display that provides detailed
graphics. "Display" is the EMACS term for a GUI.

Some users prefer the former. Some users prefer the latter. Some users prefer to
use a $4000USD machine to emulate the latter. Both are good options.

This system is configured to work pleasantly for either type of output.

** A Full Pot of EMACS on Every Desk

*** Keyboard Layout & Operation

- Use QWERTY layout.
  - Everyone knows it.
  - Easy to learn.
  - Available on every keyboard.
  - Inexpensive.
  - When graduation time comes, plenty of great alternatives available like
    DVORAK and Colemak.
- Keep hands in home position as much as possible.
  - Every finger is strong in the home position so RSI reduced.
  - Single key presses are easy there.
- Table-bang the shift, caps-lock and enter keys.
  - Table-bang is a position of your hand. Make it by:
    - Starting with your hands in the home position.
    - Make a "high-five" with both of them parallel to the keyboard.
    - Turn your left hand counter-clockwise and right hand clockwise to make
      them perpendicular to the keyboard.
    - Squeeze all of your fingers together.
    - Push the keys using the side of your Pinky.
    - In this position you are using the strength of all of your fingers.
  - Never use those key using your Pinky alone.
  - Practice depends 100% on user-discipline.
- Try to achieve balance with meta keys.
  - Provide same key of each side of the keyboard.
- Be conscious of key operations [[http://ergoemacs.org/emacs/emacs_key_notation_return_vs_RET.html][on different outputs]].
  - Always provide both.
  - Note what is getting stomped on.
  - For return bind to:
    - =RET= in the terminal.
    - =<return>= in the GUI.
  - Also for tab =TAB= vs =C-i=.
  - Also for escape =ESC= vs =C-[=

*** Understanding Your Cognitive Landscape.

You operate within a cognitive landscape. Every moment you are in a single
=place=. While residing in each =place= you perform logically related =activities=.
Activities facilitate logical actions like modification within that =place=.
Modifications are performed objects. Objects include things like the contents of
a buffer, contents of memory, or the file that backs a buffer. While performing
those =activities= there is a logical sense of "flow". That should never be
interrupted. Usually an interruption occurs when you are going to go to a new
=place=. The =distance= between =places= is measured in the similarity between the
=actions= that you find there. As you develop these ides it will be obvious where
key-bindings should go

*** Key-Bindings Take You to Places to Perform Activities

OOTB you wil be visiting many =places= and performing many =activities=. EMACS comes
with a good configuration that minimizes =distance=. This isn't worth changing.
You can use EMACS for a lifetime without ever having to customize any of the
key-bindings. This is what lets anyone use your system. This is what lets you
use the system with =-Q= when you break it. You need to decide if you every want
to alter the default configuration. This system does not want to. It wants to
keep EMACS true to EMACS and your hands happy. To satisfy those goals the
following practices were defined.

- 99.999% of the time never bind to the =C= or =M= name-space.
  - They are for system key-bindings. You can break them. Don't.
  - In theory =C-c= is the "user name-space" but packages stomp on this all of the
    time anyway so don't use it.
  - Some bindings are just too valuable to pass up:
    - =C-;=
      - Your hands are in the home position already.
    - Every modifier key with return.
- Never bind to =F= keys.
  - They are a painful stretch on most keyboards.
  - Some require a lone Pinky with is worse.
  - Most operating systems bind actions to them OOTB anyway.
  - EMACS comes with key-bindings OOTB.
- Don't try to set up a Hyper-key.
- Use shift as a name-space expansion vehicle.
  - Shift doubles every name-space in which you use it.
  - Use cautiously, not every name-space vehicle supports it.
- About the =s= (super) name-space.
  - In theory it is the best place for user-defined key-bindings because
    EMACS OOTB uses =C= and =M= completely leaving =s= mostly open.
  - In practice =C= and =M= are running out of space because there are a lot of
    new packages being added to EMACS. Most new packages are binding key
    in the =s= name-space.
  - This system reserves =s= completely for Sysop.

These practices say nothing about the =places= or =activities= that you choose to
peform. The practices only look at the key-binding configuration. There are a
limited number of keys on a keyboard and there are physical limitations on your
hands. Along with the previous assuptions it may look like there are less.
Fortunately it just looks that way and it isn't true. There are a lot of
powerful ways to "go places" with EMACS. The next heading contains my attempt.

*** How to Get There Pleasantly and Quickly

You need to learn how to use EMACS. You need to develop a personal preference.
You need to develop an idea of =places= and =activities= and =distance=. The following
headings are delineated by breaks in flow.

The examples try to talk about doing those things and do it by exploring:

- "going places to do things".
- "how quickly I will get there and how long I will be there"
- "how quickly I want to go somewhere else".

They were initially described by the properties:

- Actions :: The number of related actions in that place.
- Expertise :: The level of skill and speed with which you are performing the
  activity.
- Relationship :: How closely those activities are related in the current place.
- Frequency :: How many times you perform these actions when you here.

The relationship between "doing those things" and those 4 properties is still
unclear and being explored.

**** =s=
      :PROPERTIES:
      :Actions:          High
      :Expertise:        High
      :Relationship:     High
      :Frequency:        High
      :END:

- =Actions= here are for the =place= inside of the buffer itself. They are for
  immediate acting upon the contents of the buffer. They are logically
  related, used frequently, and likely to be memorized.
- When you come here, you are likely to stay for some time before getting
  out.
- Only use single key bindings; anything more may be a new logical
  name-space and may use a Hydra.
- Split the home sides of the keyboard in half.
- The left side of the keyboard should be use for operations common to
  every mode.
  - For example ~goto-line~ and ~ispell~.
  - It has 15 bindings available; 20 if you use 1-5. 40 if you shift them.
- The right side of the keyboard should be used operations specific to the
  current major mode.
  - For example in Org-Mode navigating between source-blocks and
    evaluating them.
  - It has 19 bindings available; 26 if you use 6-=. 52 if you shift them.

For example, in Org-Mode:

- I traverse the entire document very quickly with
  ~org-babel-previous-src-block~ and and ~org-babel-next-src-block.~
- I execute source-blocks.
- I edit source-blocks.

Every activity is related to reading, modifying, executing, and tangling code.

**** =Key-Chord=

Key-Chord is intriguing because it works on every keyboard. It is powerful
because it can you bring you to any =place= easily. It is good for taking you
places in two differnt kinds of scenarios.

One example is grammar-checking. There are a few ways to do that. I don't
remember them all. In a given mode I want to see a list of all the ways.
I really just want to see all of the stuff that I value for a given mode and
don't use frequently.

Another example are things that I value for a mode and use a lot but are not
logically related to other activities in that place. For example moving the
mark around and going to lines are performed a lot so they need to be done
quickly and left. This is a place where key-chords and the shift modifier are
a fast and intuitive way to go places.

***** Single-Key Key-Chord Name-Space.
      :Actions:          High
      :Expertise:        Low
      :Frequency:        High
      :Relationship:     Low

- Nice if you don't mind hitting the same key twice.
- You will use come here often, perform your single =action=, and be done
  and leave very frequently and quickly.
- Using alphabetical characters always results in unpleasant surprises.
- Harder for breakage but it still occurs.
  - =#FF= color code.
  - =cc= carbon copy.
  - JJ nick-name.
- Symbols are more likely to be safer bets.
  - Only use the symbols.
    - 8 if you use rows 3-4; 16 if you shift.
    - Fifth row has 13; 26 with shift.
- Good vehicle to reach a Hydra.

***** Two-Key Key-Chord Name-Space.
      :Actions:          Low
      :Expertise:        High
      :Frequency:        High
      :Relationship:     Low

- Very attractive.
- Nice if you don't like hitting the same key twice.
- Easy to use all fingers.
  - Finger strength is not an issue here; use any of them.
- Unexpected breakage very easy.
  - =cd= in ~=eshell=~.
- Use sparingly.
- Not worth analyzing ideal combinations; just use it and see if it
  doesn't break.
- Bringing over existing bindings. They are all for every mode so I will
  keep it that way.

**** =Hydra=
      :PROPERTIES:
      :Actions:          High
      :Expertise:        Low
      :Frequency:        Low
      :Relationship:     High
      :END:

- Sometimes you want to do something in a =place= but you aren't sure what
  and you aren't sure where you will go next from there. For example you
  might want to perform an Org-Mode =action= that is important but you don't
  really use much. For example exporting to HTML might not be common for
  you but you value.
- =Hydras= can be used for very related actions too. The difference between
  the =s= name-space is the distance between them and where you are now.
  In the =s= namespace you go there very quickly. For =Hydras= sometimes you
  can get the fast and sometimes more slowly. They are complementary to
  every name-space.

For example, in Org-Mode I am still learning about functions and haven't used
them much and forget their names. It is faster to put them in a Hydra. If they
get used a lot, I will add them to =s=.

*** Building Your Own Keyboard

As your mastery of EMACS grows so too will your desire to build your own
keyboard. It is natural. As you explore various dimensions of expression you
will have a lot of fun. You will act more quickly and skillfully. Even with the
goals of this system in place the desire grows.

3D printing is one area worth exploring. A lot of EMACS users design and print
their own custom keyboards. That looks very fun. [[http://scripts.sil.org/cms/scripts/page.php?site_id%3Dnrsi&id%3Dukelele][Ukulele]] is softer way to
explore your keyboard. Reading its user manual is important. It contains ideas
about stack-able-environments for bindings. You may use Ukulele or Hydras to do
the same thing. [[https://pqrs.org/osx/karabiner/][Karabiner]] is a nice way to re-map your keys. It's easiest
adjustment is to make return act as return when pressed alone and as control
when pressed with another key. That introduces a symmetry to your keyboard which
can be helpful. All of those dimensions are worth exploring.

When I explored them I felt that they led me further away from the majority of
users. Every time explored a different key-mapping (not key-binding) it reduced
accessibility for new users. Each time I tried to work around that hiccup. The
last pursuit was =;= and space.

It would be great to set up your keyboard with the meta keys on the bottom
like this:

#+BEGIN_EXAMPLE
+---------------------------------------+
| +-----+                       +-----+ |
| |RET  |                       |  RET| |
| +-----+                       +-----+ |
| +------+                     +------+ |
| |SHIFT |                     | SHIFT| |
| +------+                     +------+ |
|        +-+ +-+ +-----+ +-+ +-+        |
|        |s| |M| |C/spc| |M| |s|        |
|        +-+ +-+ +-----+ +-+ +-+        |
|                                       |
+---------------------------------------+
#+END_EXAMPLE

Karabiner was too slow for my typing speed though. It [[https://www.reddit.com/r/emacs/comments/38qllb/karabiner_space_as_control/][happens]]. It seemed like a
minimal change to use Ukelele to:

- Make space send =C=
- Make =;= send space
- Make ='= a dead key
  - In it's dead key state make
    - =;= \rarr =;=
    - =:= \rarr =:=
    - ='= \rarr ='=
    - ="= \rarr ="=

The trouble is that it violates the POLA. Therefore, I left it alone and stuck
with a simple "Get C on both sides".

That has worked out very well. It is very easy to do on every operating system.
It holds true to the values of this system. When you develop an idea of =places= and
how often you go there the key-mapping becomes more obvious. Make it easy to get
to key-bindings that take you to familiar places. For this system it is the home
keys, =s=, and =key-chord=. Make those keys more easily accessible. =C= and =M= often
have symmetric-definitions. =s= and =SHIFT= also often have symmetric definitions in
this system (mostly through Key-Chords). Therefore those key-mappings are kept
close together

#+BEGIN_EXAMPLE
+---------------------------------------+
| +-----+                       +-----+ |
| |s    |                       |s/ret| |
| +-----+                       +-----+ |
| +------+                     +------+ |
| |SHIFT |                     | SHIFT| |
| +------+                     +------+ |
|        +-+ +-+ +-----+ +-+ +-+        |
|        |M| |C| |spc  | |C| |M|        |
|        +-+ +-+ +-----+ +-+ +-+        |
|                                       |
+---------------------------------------+
#+END_EXAMPLE

** Take a Sip

Because Use-Package is used in this system, the binding definitions often live
in the call itself.

*** Left Side

**** 4

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "s-w") #'imenu)
#+END_SRC

**** Unsorted

VC activities.

#+BEGIN_SRC emacs-lisp
(define-prefix-command 'help/vc-map)
(global-set-key (kbd "s-r") #'help/vc-map)
(define-key help/vc-map "e" #'help/safb-vc-ediff)
(define-key help/vc-map "d" #'help/safb-vc-diff)
(define-key help/vc-map "u" #'help/safb-vc-revert)
(global-set-key (kbd "s-f") #'help/safb-help-vc-next-action)
#+END_SRC

Go to a line.

#+BEGIN_SRC emacs-lisp
(key-chord-define-global "fg" #'goto-line)
#+END_SRC

Pop the mark back.

#+BEGIN_SRC emacs-lisp
(key-chord-define-global "FG" #'pop-to-mark-command)
#+END_SRC

Do the /right thing/ for getting to the start of the line.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-a") #'beginning-of-line-dwim)
#+END_SRC

Occur has 3 cases. I like to use it to explore the unknown.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-s p") 'help/occur-dwim)
#+END_SRC

Simpler buffer movement.

#+BEGIN_SRC emacs-lisp
(key-chord-define-global "fv" #'help/safb-other-window)
#+END_SRC

Toggle utility buffers ("logical F" key, so left side; "logical J" key on
right).

#+BEGIN_SRC emacs-lisp
(key-chord-define-global "f9" #'help/util-cycle)
#+END_SRC

Hide and show code blocks.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "s-b") 'hs-toggle-hiding)
#+END_SRC

***  Left & Right Side

#+BEGIN_SRC emacs-lisp
(key-chord-define-global "qi" #'help/comment-or-uncomment)
#+END_SRC

Make =ispell= accessible.

#+BEGIN_SRC emacs-lisp
(key-chord-define-global "qp" #'ispell)
(key-chord-define-global "qo" #'ispell-word)
#+END_SRC

Writegood too.

#+BEGIN_SRC emacs-lisp
(key-chord-define-global "wm" #'writegood-mode)
(key-chord-define-global "wl" #'writegood-grade-level)
(key-chord-define-global "wz" #'writegood-reading-ease)
#+END_SRC

Use the default Langtool bindings.

#+BEGIN_SRC emacs-lisp
(define-prefix-command 'help/langtool-map)
(key-chord-define-global "qk" #'help/langtool-map)
(define-key help/langtool-map "c" #'langtool-check-buffer)
(define-key help/langtool-map "C" #'langtool-correct-buffer)
(define-key help/langtool-map "j" #'langtool-goto-previous-error)
(define-key help/langtool-map "k" #'langtool-show-message-at-point)
(define-key help/langtool-map "l" #'langtool-goto-next-error)
(define-key help/langtool-map "q" #'langtool-check-done)
#+END_SRC

*** Right Side

Try to reserve the right side for mode-specific activities.

*** Exceptions

Return.

Do smart new line inside, indenting given the mode.

#+BEGIN_SRC emacs-lisp
(help/not-on-gui (global-set-key (kbd "s-RET") #'help/smart-open-line))
(help/on-gui (global-set-key (kbd "s-<return>") #'help/smart-open-line))
#+END_SRC

Scroll the whole buffer by one line keeping the cursor with it.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-n") (kbd "C-u 1 C-v"))
(global-set-key (kbd "M-p") (kbd "C-u 1 M-v"))
#+END_SRC

Use a nicer =eval-expression= approach.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "s-:") #'my-eval-expression)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "s-C-n") #'next-line)
(global-set-key (kbd "C-n") #'next-logical-line)
(global-set-key (kbd "s-C-p") #'previous-line)
(global-set-key (kbd "C-p") #'previous-logical-line)
#+END_SRC

* Special Operating Procedure
   :PROPERTIES:
   :noweb-ref: Special-Operating-Procedure
   :END:

The following code and packages are special to this configuration. They provide
critical functionality for configuring the rest of the system. They provide
ideas that make the entire system usable, productive, expressive, and fast.

** Display

Make it easy to conditionally evaluate code when running with a graphical
display.

#+BEGIN_SRC emacs-lisp
(defmacro help/on-gui (statement &rest statements)
  "Evaluate the enclosed body only when run on GUI."
  `(when (display-graphic-p)
     ,statement
     ,@statements))

(defmacro help/not-on-gui (statement &rest statements)
  "Evaluate the enclosed body only when run on GUI."
  `(when (not (display-graphic-p))
     ,statement
     ,@statements))

#+END_SRC

** Keyboard

Key-Chord mode is amazing. Piano-Lessons shows you how.

#+BEGIN_SRC emacs-lisp
(use-package key-chord
  :ensure t
  :config
  (key-chord-mode t)
  (setq key-chord-two-keys-delay 0.1))
#+END_SRC

Echo keystrokes immediately.

#+BEGIN_SRC emacs-lisp
(setq echo-keystrokes 0.02)
#+END_SRC

** Libraries

Dash is nice to use.

#+BEGIN_SRC emacs-lisp
(use-package dash
  :ensure t
  :config
  (dash-enable-font-lock))
(use-package dash-functional
  :ensure t)
#+END_SRC

F is nice to use.

#+BEGIN_SRC emacs-lisp
(use-package f
  :ensure t)
#+END_SRC

S is nice to use.

#+BEGIN_SRC emacs-lisp
(use-package s
  :ensure t)
#+END_SRC

Generate a UUID.

#+BEGIN_SRC emacs-lisp
(use-package uuid
  :ensure t)
#+END_SRC

** Modeline

Reduce information about modes in the Modeline.

#+BEGIN_SRC emacs-lisp
(use-package diminish)
#+END_SRC

Show the file size.

#+BEGIN_SRC emacs-lisp
(size-indication-mode)
#+END_SRC

Show the column number.

#+BEGIN_SRC emacs-lisp
(column-number-mode t)
#+END_SRC

** OSX

Make it easy to evaluate code only when running on OSX.

#+BEGIN_SRC emacs-lisp
(defmacro help/on-osx (statement &rest statements)
  "Evaluate the enclosed body only when run on OSX."
  `(when (eq system-type 'darwin)
     ,statement
     ,@statements))
#+END_SRC

Pull in the =ENVIRONMENT= variables because the GUI version of EMACS does not.

#+BEGIN_SRC emacs-lisp
(help/on-osx
 (use-package exec-path-from-shell
   :ensure t
   :config
   (exec-path-from-shell-initialize)))
#+END_SRC

Configure the meta keys.

Enable the =super= key-space.

#+BEGIN_SRC emacs-lisp
(help/on-osx
 (setq mac-control-modifier 'control)
 (setq mac-command-modifier 'meta)
 (setq mac-option-modifier 'super))
#+END_SRC

EMACS dialogues don't work OSX. They lock up EMACS.

This is a known issue. [[https://superuser.com/questions/125569/how-to-fix-emacs-popup-dialogs-on-mac-os-x][Here]] is the solution.

#+BEGIN_SRC emacs-lisp
(help/on-osx
 (defun help/yes-or-no-p (orig-fun &rest args)
   "Prevent yes-or-no-p from activating a dialog."
   (let ((use-dialog-box nil))
     (apply orig-fun args)))
 (advice-add 'yes-or-no-p :around #'help/yes-or-no-p)
 (advice-add 'y-or-n-p :around #'help/yes-or-no-p))
#+END_SRC

** Windows

Make it easy to evaluate code only when running on Windows.

#+BEGIN_SRC emacs-lisp
(defmacro help/on-windows (statement &rest statements)
  "Evaluate the enclosed body only when run on Microsoft Windows."
  `(when (eq system-type 'windows-nt)
     ,statement
     ,@statements))
#+END_SRC

Provide the proper shell.

#+BEGIN_SRC emacs-lisp
(help/on-windows
 (setq shell-file-name "cmdproxy.exe"))
#+END_SRC

Enable the =super= key-space.

#+BEGIN_SRC emacs-lisp
(help/on-windows
 (setq w32-lwindow-modifier 'super)
 (setq w32-rwindow-modifier 'super))
#+END_SRC

* Standard Operating Procedure
   :PROPERTIES:
   :noweb-ref: Standard-Operating-Procedure
   :END:

Configure EMACS to maximum utility.

** Buffer

Maintain buffers across sessions. Desktop-Save-Mode persists very part of the
buffer. If you upgrade a package that uses buffer-variables that have changed
you may get unexpected behavior. Close all buffers and open them again after
making such breaking changes.

#+BEGIN_SRC emacs-lisp
(desktop-save-mode t)
(setq desktop-restore-eager 10)
#+END_SRC

Provide expected "Undo" functionality.

#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :ensure t
  :config
  (global-undo-tree-mode 1)
  :diminish undo-tree-mode)
#+END_SRC

Ensure that buffers do not end with a new line. This is the decision of Sysop.
This is important to YASnippets and Source-Blocks. Doing so would violate POLA.

#+BEGIN_SRC emacs-lisp
(setq require-final-newline nil)
#+END_SRC

If you are on the end of a line, and go up or down, then go to the end of
line on that new line. Do not account for anything special about the character
there.

#+BEGIN_SRC emacs-lisp
(setq track-eol t)
(setq line-move-visual nil)
#+END_SRC

Take the cursor with scroll activities.

#+BEGIN_SRC emacs-lisp
(setq scroll-preserve-screen-position t)
#+END_SRC

More easily visualize tabular data. Considered to non-subjective.

#+BEGIN_SRC emacs-lisp
(use-package stripe-buffer
  :ensure t)
#+END_SRC

End sentences with a single space.

#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC

Ban white-space at end of lines, globally.

#+BEGIN_SRC emacs-lisp
(add-hook #'before-save-hook #'help/delete-trailing-whitespace)
#+END_SRC

Intelligently select the current char, then word, then object, then block,
then document.

#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :ensure t
  :config
  (global-set-key (kbd "s-d") #'er/expand-region))
#+END_SRC

80 characters is wide enough for most documents.

#+BEGIN_SRC emacs-lisp
(setq help/column-width 80)
#+END_SRC

** Code Folding

#+BEGIN_SRC emacs-lisp
(use-package hideshow
  :config
  (setq hs-hide-comments-when-hiding-all t)
  (setq hs-isearch-open t)
  (defun display-code-line-counts (ov)
    "Displaying overlay content in echo area or tooltip"
    (when (eq 'code (overlay-get ov 'hs))
      (overlay-put ov 'help-echo
                   (buffer-substring (overlay-start ov)
                                     (overlay-end ov)))))
  (setq hs-set-up-overlay #'display-code-line-counts)
  (defun help/goto-line (&rest args)
    "How do I get it to expand upon a goto-line? hideshow-expand affected block when using goto-line in a collapsed buffer."
    (save-excursion
      (hs-show-block)))
  (advice-add #'goto-line :after #'help/goto-line)
  :diminish hs-minor-mode)
#+END_SRC

** Colors

Colorize color names.

Rainbow-Mode handles most major modes color definitions as expected.

#+BEGIN_SRC emacs-lisp
(use-package rainbow-mode
  :ensure t
  :config
  :diminish rainbow-mode)
#+END_SRC

** Evaluation

#+BEGIN_SRC emacs-lisp
(setq-default eval-expression-print-level nil)
#+END_SRC

Allow most commands.

#+BEGIN_SRC emacs-lisp
(put 'upcase-region 'disabled nil)
(put 'downcase-region 'disabled nil)
(put 'narrow-to-region 'disabled nil)
#+END_SRC

** Encryption

Easy to use file-based AES encryption.

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path (getenv "CCRYPT"))
(use-package ps-ccrypt)
#+END_SRC

** Eshell

Provide a cross-platform command line shell that is a first-class EMACS citizen.

Commands input in eshell are delegated in order to an alias, a built in command,
an Elisp function with the same name, and finally to a system call. Semicolons
separate commands. =which= tells you what implementation will satisfy the call
that you are going to make. The flag =eshell-prefer-lisp-functions= does what it
says. =$$= is the result of the last command. Aliases live in
=eshell-aliases-file=. History is maintained and expandable. =eshell-source-file=
will run scripts. Since Eshell is not a terminal emulator, you need to configure
it for any commands that need to run using a terminal emulator by adding it to
to =eshell-visual-commands=.

#+BEGIN_SRC emacs-lisp
(setq eshell-prefer-lisp-functions nil
      eshell-cmpl-cycle-completions nil
      eshell-save-history-on-exit t
      eshell-cmpl-dir-ignore "\\`\\(\\.\\.?\\|CVS\\|\\.svn\\|\\.git\\)/\\'")

(eval-after-load 'esh-opt
  '(progn
     (use-package em-cmpl)
     (use-package em-prompt)
     (use-package em-term)
     (setenv "PAGER" "cat")
     (add-hook 'eshell-mode-hook
               (lambda ()
                 (message "Welcome to Eshell.")
                 (setq pcomplete-cycle-completions nil)))
     (add-to-list 'eshell-visual-commands "ssh")
     (add-to-list 'eshell-visual-commands "tail")
     (add-to-list 'eshell-command-completions-alist
                  '("tar" "\\(\\.tar|\\.tgz\\|\\.tar\\.gz\\)\\'"))))
#+END_SRC

Configure a =PS1= like prompt.

#+BEGIN_SRC emacs-lisp
(setq eshell-prompt-regexp "^.+@.+:.+> ")
(setq eshell-prompt-function
      (lambda ()
        (concat
         (user-login-name)
         "@"
         (system-name)
         ":"
         (eshell/pwd)
         "> ")))
#+END_SRC

** File Based System

This system uses artifacts stored in files. It tries to persist file-stores
every chance it gets without interrupting the user's flow. Flow is important.

Don't create backup files. Instead Git for versioning

Automatically back file-stores if no activity has occurred.

#+BEGIN_SRC emacs-lisp
(setq auto-save-default t)
(setq make-backup-files nil)
(setq auto-save-visited-file-name t)
(setq auto-save-interval 0)
(setq auto-save-timeout (* 60 5))
#+END_SRC

Backup file-stores when the frame loses focus.

#+BEGIN_SRC emacs-lisp
(add-hook 'focus-out-hook #'help/save-all-file-buffers)
#+END_SRC

Backup file-stores before the system exits.

#+BEGIN_SRC emacs-lisp
(advice-add #'save-buffers-kill-terminal :before #'help/save-all-file-buffers)
#+END_SRC

Always keep buffers in-sync with changes in-file.

#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode 1)
#+END_SRC

Save all file befores before common activities. Functions are easier to
use than advice.

#+BEGIN_SRC emacs-lisp
(defun help/safb-help-vc-next-action ()
  (interactive)
  (help/save-all-file-buffers)
  (help/vc-next-action))

(defun help/safb-vc-ediff ()
  (interactive)
  (help/save-all-file-buffers)
  (vc-ediff nil))

(defun help/safb-vc-diff ()
  (interactive)
  (help/save-all-file-buffers)
  (vc-diff nil))

(defun help/safb-vc-revert ()
  (interactive)
  (help/save-all-file-buffers)
  (vc-revert))

(defun help/safb-magit-status ()
  (interactive)
  (help/save-all-file-buffers)
  (magit-status))

(defun help/safb-org-babel-tangle ()
  (interactive)
  (help/save-all-file-buffers)
  (let ((start (current-time)))
    (message (concat "org-babel-tangle BEFORE: <"
                     (format-time-string "%Y-%m-%dT%T%z")
                     ">"))
    (org-babel-tangle)
    (let* ((dur (float-time (time-since start)))
           (msg (format "Tangling complete after: %.06f seconds" dur)))
      (message (concat "org-babel-tangle AFTER: <"
                       (format-time-string "%Y-%m-%dT%T%z")
                       ">"))
      (message msg)
      (help/on-gui (alert msg :title "org-mode")))))

(defun help/safb-other-window ()
  (interactive)
  (help/save-all-file-buffers)
  (other-window 1))

(defun help/safb-org-edit-src-code ()
  (interactive)
  (help/save-all-file-buffers)
  (org-edit-src-code))

(defun help/safb-help/org-edit-src-code-plus-name ()
  (interactive)
  (help/save-all-file-buffers)
  (help/org-edit-src-code-plus-name))

(defun help/safb-org-export-dispatch ()
  (interactive)
  (help/save-all-file-buffers)
  (org-export-dispatch))

(defun help/safb-TeX-command-master (&optional arg)
  (interactive)
  (help/save-all-file-buffers)
  (TeX-command-master arg))
#+END_SRC

Selection:

- Don't perform on frequent keys like enter and line navigation.

Future candidates:

- avy jump
- dired
- eshell
- ess-rdired
- eval-defun
- eval-region
- help/newline
- goto-line
- ido-switch-buffer
- ielm
- ispell
- ispell-word
- langtool-check-buffer
- newline-and-indent
- next-line
- org-edit-src-exit
- org-return
- pop-to-mark-command
- previous-line
- sp-newline
- with-current-buffer
- writegood-mode

Try to visit a non-existent file and get prompted to create its parent
directories.

#+BEGIN_SRC emacs-lisp
(add-to-list 'find-file-not-found-functions #'help/create-non-existent-directory)
#+END_SRC

** File-system/directory management (Console)

You can use the usual machinery to work with the files. Highlight a region
and operation selections occur for all files in that region. Commands are
scheduled, and then executed, upon your command. Files can be viewed in modify
or read-only mode, too. There is an idea of =mark= in files, which is to select
them and perform operations on the marked files. There are helper methods for
most things you can think if like directories or modified-files or whatever,
meaning you can use regexen to mark whatever you like however you like. If that
suits you, then don't be afraid of using the regular expression builder
that is built into EMACS. Bulk marked file operations include additionally
copying, deleting, creating hard links to, renaming, modifying the mode,
owner, and group information, changing the time-stamp, listing the marked
files, compressing them, decrypting, verifying and signing, loading or byte
compiling them (Lisp files).

=g= updates the current buffer; =s= orders the listing by alpha or date-time.

=find-name-dired= beings the results back into Dired, which is nifty.

Wdired lets you modify files directly via the UI, which is interesting. Image-Dired
lets you do just that.

=+= creates a new directory. =dired-copy-filename-as-kill= stores the list of
files you have selected in the kill ring. =dired-compare-directories= lets you
perform all sorts of directory comparisons, a handy tool that you need once in
a while but definitely do need.
#+BEGIN_SRC emacs-lisp
(defun help/dired-copy-filename ()
  "Push the path and filename of the file under the point to the kill ring.
  Attribution: URL `https://lists.gnu.org/archive/html/help-gnu-emacs/2002-10/msg00556.html'"
  (interactive)
  (message "Added %s to kill ring" (kill-new (dired-get-filename))))
(defun help/dired-copy-path ()
  "Push the path of the directory under the point to the kill ring."
  (interactive)
  (message "Added %s to kill ring" (kill-new default-directory)))
(setq dired-listing-switches "-alh")
(setq dired-recursive-deletes 'top)
(use-package dired-details+
  :ensure t)
(setq-default dired-details-hidden-string "")
(defun help/dired-mode-hook-fn ()
  "HELP dired customizations."
  (local-set-key "c" 'help/dired-copy-filename)
  (local-set-key "]" 'help/dired-copy-path)
  (diff-hl-dired-mode)
  (load "dired-x")
  (turn-on-stripe-buffer-mode)
  (stripe-listify-buffer))
(add-hook #'dired-mode-hook #'help/dired-mode-hook-fn)
#+END_SRC

Try to guess the target directory for operations.
#+BEGIN_SRC emacs-lisp
(setq dired-dwim-target t)
#+END_SRC

Use EMACS =ls=.
#+BEGIN_SRC emacs-lisp
(help/on-osx
 (setq ls-lisp-use-insert-directory-program nil)
 (use-package ls-lisp))
#+END_SRC

After dabbling, something happened that really changed my mind. These three
articles changed everything: [[http://www.masteringemacs.org/articles/2014/04/10/dired-shell-commands-find-xargs-replacement/][Dired Shell Command]], [[https://www.masteringemacs.org/article/working-multiple-files-dired][
Working with multiple files in dired]], and [[https://www.masteringemacs.org/article/wdired-editable-dired-buffers][WDired: Editable Dired Buffers]]..
They just made the power of Dired so obvious, and so easy to use, that it
instantly because delightful to use. That was very, very cool. Even though I
was really, really happy with Finder and Explorer… suddenly it just became so
obvious and pleasant to use Dired. That is so wild.

Key notes when executing shell commands on file selection…

Substitution:
- =<cmd> ?= :: 1* calls to cmd, each file a single argument
- =<cmd> *= :: 1 call to =cmd=, selected list as argument
- =<cmd> *""= :: have the shell expand the * as a globbing wild-card
  - Not sure what this means

Synchronicity:
- =<cmd> …= :: by default commands are called synchronously
- =<cmd> &= :: execute in parallel
- =<cmd> ;= :: execute sequentially, asynchronously
- =<cmd> ;&= :: execute in parallel, asynchronously

Key notes on working with files in multiple directories… use the following:

Use =find= just like you would at the command line and all of the results show
up in a single Dired buffer that you may work with just like you would any other
file appearing in a Dired buffer. The abstraction here becomes so obvious, you
may ask yourself why you never considered such a thing /before/ now (as I did):
#+BEGIN_SRC emacs-lisp
(use-package find-dired
  :ensure t
  :config
  (setq find-ls-option '("-print0 | xargs -0 ls -ld" . "-ld")))
#+END_SRC

Noting that:
- =find-dired= :: is the general use case
- =find-name-dired= :: is for simple, single string cases

And if you want to use the faster Elisp version, that uses lisp regex, use:
- =find-lisp-find-dired= :: for anything
- =find-lisp-find-dired-subdirectories= :: for only directories

Key notes on working with editable buffers…

As the author notes, you probably already instinctually knew what is possible.
After reading his brief and concise exposition, it would be hard /not/ to
intuit what is possible! The options are big if you make a writable file buffer.
Think about using multiple cursors. Done? Well, that is a no-brainer. Once you
grok multiple cursors just =find-dired= what you need and then do what you need
to do to it. Very cool.

- =dired-toggle-read-only, C-x C-q= :: cycle between dired-mode and wdired-mode
- =wdired-finish-edit, C-c C-c= :: commit your changes
- =wdired-abort-changes, C-c ESC= :: revert your changes

#+BEGIN_SRC emacs-lisp
(use-package wdired
  :ensure t
  :config
  (setq wdired-allow-to-change-permissions t)
  (setq wdired-allow-to-redirect-links t)
  (setq wdired-use-interactive-rename t)
  (setq wdired-confirm-overwrite t)
  (setq wdired-use-dired-vertical-movement 'sometimes))
#+END_SRC

When you selected a bunch of files or directories, you /may/ want to communicate
somewhere your selection somehow. The simplest way to do this is to utilize
=dired-copy-filename-as-kill=. What a nice idea, and its default binding is =w=.

Since I started using a menu bar again, and wanting to get Imenu really
exercised, Dired in Imenu seems like an obvious choice.

#+BEGIN_SRC emacs-lisp
(use-package dired-imenu
  :ensure t)
#+END_SRC

** IMenu

Major productivity hack

#+BEGIN_SRC emacs-lisp
(use-package imenu
  :config
  (setq imenu-sort-function 'imenu--sort-by-name))
(defun help/try-to-add-imenu ()
  "Add Imenu to modes that have `font-lock-mode' activated.

Attribution: SRC http://www.emacswiki.org/emacs/ImenuMode"
  (condition-case nil (imenu-add-to-menubar "Imenu") (error nil)))
(add-hook #'font-lock-mode-hook #'help/try-to-add-imenu)
#+END_SRC

** Interactively DO Things”

IDO is used everywhere possible.

Access nearly every object available in this system from one place.

These configurations are performed in the correct order. Any attempt to refactor
this Source-Block will break Ido in this system.

#+BEGIN_SRC emacs-lisp
(use-package ido)
(use-package flx-ido
             :ensure t
             :config
             (ido-mode t))
(use-package ido-hacks
             :ensure t)
(use-package ido-ubiquitous
             :ensure t
             :config
             (ido-ubiquitous-mode t)
             (setq ido-create-new-buffer 'always)
             (flx-ido-mode t)
             (setq ido-use-faces nil))
(use-package ido-vertical-mode
             :ensure t
             :config
             (ido-vertical-mode t)
             (setq ido-vertical-define-keys 'C-n-C-p-up-down-left-right))
(global-set-key (kbd "s-x") #'ido-find-file)
(global-set-key (kbd "s-c") #'ido-switch-buffer)
#+END_SRC

Make functions search-able.

#+BEGIN_SRC emacs-lisp
(use-package smex
             :ensure t
             :config
             (smex-initialize)
             (global-set-key (kbd "s-v") #'smex))
#+END_SRC

Make URLs a first-class object.

#+BEGIN_SRC emacs-lisp
(setq ido-use-url-at-point t)
(setq ido-use-filename-at-point 'guess)
#+END_SRC

** Font

Use Unicode-Font to provide as many Unicode fonts as possible.

Here are the Unicode fonts that provide nearly everything.

| Name    | Version | URL | Comments                 |
|---------+---------+-----+--------------------------|
| [[http://sourceforge.net/projects/dejavu/files/dejavu/2.34/dejavu-fonts-ttf-2.34.tar.bz2][DejaVu]]  |    2.43 | [[http://sourceforge.net/projects/dejavu/files/dejavu/2.34/dejavu-fonts-ttf-2.34.tar.bz2][.]]   | Modern classic           |
| [[http://users.teilar.gr/~g1951d/][Symbola]] |    7.17 | [[http://users.teilar.gr/~g1951d/Symbola.zip][.]]   | Neat                     |
| [[http://www.quivira-font.com/][Quivira]] |     4.0 | [[http://www.quivira-font.com/files/Quivira.otf][.]]   | Amazing                  |
| [[https://code.google.com/p/noto/][Noto]]    |       ? | [[http://noto.googlecode.com/git/fonts/individual/hinted/NotoSans-Regular.ttc][1]] [[http://noto.googlecode.com/git/fonts/individual/unhinted/NotoSansSymbols-Regular.ttf][2]] | Has morse code, and more |

To test it run =view-hello-file= and =M-x list-charset-chars RET unicode-bmp RET=.

Perhaps educationally there is a character for bowel-movements: 💩.

#+BEGIN_SRC emacs-lisp
(use-package unicode-fonts
  :ensure t
  :config
  (unicode-fonts-setup))
#+END_SRC

Activate font locking everywhere possible.

#+BEGIN_SRC emacs-lisp
(global-font-lock-mode t)
#+END_SRC

Visualize ASCII values as their most likely Unicode representation.

#+BEGIN_SRC emacs-lisp
(use-package pretty-mode
  :ensure t
  :config
  (global-pretty-mode))
#+END_SRC

** Going to Objects

Go to any object in the frame quickly.

#+BEGIN_SRC emacs-lisp
(use-package avy
  :ensure t
  :config
  (key-chord-define-global "df" #'avy-goto-word-1)
  (key-chord-define-global "DF" #'avy-pop-mark))
#+END_SRC

** Grammar

#+BEGIN_SRC emacs-lisp
(use-package writegood-mode
  :ensure t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package langtool
  :ensure t
  :init
  (setq langtool-language-tool-jar (concat (getenv "EELIB") "/LanguageTool-2.8/languagetool-commandline.jar"))
  (setq langtool-mother-tongue "en")
  (setq langtool-java-bin (concat (getenv "JAVA_HOME") "/bin/java")))
#+END_SRC

** Intellisense (Auto Completion)

#+BEGIN_SRC emacs-lisp
(use-package fuzzy
  :ensure t)
(use-package auto-complete
  :ensure t
  :config
  (use-package auto-complete-config)
  (setq ac-quick-help-prefer-pos-tip nil)
  (ac-config-default)
  (setq ac-auto-start nil)
  (help/not-on-gui (ac-set-trigger-key "\t"))
  (help/on-gui (ac-set-trigger-key "<tab>"))
  :diminish auto-complete-mode)
(use-package auto-complete-chunk
  :ensure t)
#+END_SRC

Auto-completion for =.=-separated words.

#+BEGIN_SRC emacs-lisp
(use-package auto-complete-chunk
  :ensure t)
#+END_SRC

** Macros

The macro recorder and Multiple-Cursors provide two ways to do the right thing
in different situations.

#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
  :ensure t
  :config
  (global-set-key (kbd "s-4") #'mc/mark-next-like-this)
  (global-set-key (kbd "s-3") #'mc/mark-previous-like-this)
  (global-set-key (kbd "s-2") #'mc/mark-all-like-this)
  (global-set-key (kbd "s-1") #'mc/edit-lines))
#+END_SRC

** Mark and Region

When you start typing and text is selected, replace it with what you are typing,
or pasting

#+BEGIN_SRC emacs-lisp
(delete-selection-mode t)
#+END_SRC

** Minibuffer

Make it easier to answer questions.
#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

Comfortably display information.
#+BEGIN_SRC emacs-lisp
(setq resize-mini-windows t)
(setq max-mini-window-height 0.33)
#+END_SRC

Allow recursive commands-in-commands and highlight the levels of recursion.
#+BEGIN_SRC emacs-lisp
(setq enable-recursive-minibuffers t)
(minibuffer-depth-indicate-mode t)
#+END_SRC

** Mouse

Scroll pleasantly with the mouse wheel. A slow turn moves the buffer up and down
one line at a time. So does a fast turn. Anything further than 5-10 lines deserves
a fast navigation vehicle.

#+BEGIN_SRC emacs-lisp
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1)))
(setq mouse-wheel-progressive-speed nil)
(setq mouse-wheel-follow-mouse t)
#+END_SRC

** Occur

#+BEGIN_SRC emacs-lisp
(defun help/occur-mode-hook-fn ()
  "HELP customizations."
  (interactive)
  (turn-on-stripe-buffer-mode)
  (stripe-listify-buffer))
(add-hook #'occur-mode-hook #'help/occur-mode-hook-fn)
#+END_SRC

** Popups

Provide popup notifications.

#+BEGIN_SRC emacs-lisp
(use-package alert
  :ensure t
  :config
  (setq alert-fade-time 10)
  (help/on-gui
   (help/on-osx
    (setq alert-default-style 'growl)))
  (setq alert-reveal-idle-time 120))
#+END_SRC

** Projects

Directories that have Git working copies are logically projects. Manage them
with Projectile.

#+BEGIN_SRC emacs-lisp
(use-package projectile
  :ensure t
  :config
  (projectile-global-mode t)
  (global-set-key (kbd "s-z") #'projectile-find-file)
  (help/on-windows
   (setq projectile-indexing-method 'alien))
  :diminish projectile-mode)
#+END_SRC

Notify Magit about every working copy that Projectile knows about.

#+BEGIN_SRC emacs-lisp
(eval-after-load "projectile"
  '(progn (setq magit-repository-directories (mapcar (lambda (dir)
                                                       (substring dir 0 -1))
                                                     (remove-if-not (lambda (project)
                                                                      (file-directory-p (concat project "/.git/")))
                                                                    (projectile-relevant-known-projects)))

                magit-repository-directories-depth 1)))
#+END_SRC

** Replacing

Display information about search-and-or-replace operation.

#+BEGIN_SRC emacs-lisp
(use-package anzu
             :ensure t
             :config
             (global-anzu-mode t)
             (global-set-key (kbd "M-%") 'anzu-query-replace)
             (global-set-key (kbd "C-M-%") 'anzu-query-replace-regexp)
             (setq anzu-mode-lighter "")
             (setq anzu-deactivate-region t)
             (setq anzu-search-threshold 1000)
             (setq anzu-replace-to-string-separator " => "))
#+END_SRC

** Save History of All Things

It is nice to have commands and their history saved so that every time you get
back to work, you can just re-run stuff as you need it.

#+BEGIN_SRC emacs-lisp
(setq savehist-save-minibuffer-history 1)
(setq savehist-additional-variables
      '(kill-ring
        search-ring
        regexp-search-ring))
(savehist-mode t)
#+END_SRC

** Searching

When searching allow a space to many any number.

#+BEGIN_SRC emacs-lisp
(setq isearch-lax-whitespace t)
(setq isearch-regexp-lax-whitespace t)
#+END_SRC

Make searches case-insensitive.

#+BEGIN_SRC emacs-lisp
(setq-default case-fold-search t)
#+END_SRC

** Spell Checking

Ispell is simple and powerful.

*** Org-Mode

Never ispell the following objects.

Source-Blocks.

#+BEGIN_SRC emacs-lisp
(add-to-list 'ispell-skip-region-alist '("^#\\+begin_src ". "#\\+#+end_src$"))
(add-to-list 'ispell-skip-region-alist '("^#\\+BEGIN_SRC ". "#\\+#+END_SRC$"))
#+END_SRC

Example-Blocks. This system often uses Source-Blocks to edit content and
Example-Blocks to make it easily renderable when it is not for running.

#+BEGIN_SRC emacs-lisp
(add-to-list 'ispell-skip-region-alist '("^#\\+begin_example ". "#\\+end_example$"))
(add-to-list 'ispell-skip-region-alist '("^#\\+BEGIN_EXAMPLE ". "#\\+END_EXAMPLE$"))
#+END_SRC

Properties.

#+BEGIN_SRC emacs-lisp
(add-to-list 'ispell-skip-region-alist '("\:PROPERTIES\:$" . "\:END\:$"))
#+END_SRC

Footnotes.

#+BEGIN_SRC emacs-lisp
(add-to-list 'ispell-skip-region-alist '("\\[fn:.+:" . "\\]"))
#+END_SRC

Footnotes with URLs that contain line-breaks.

#+BEGIN_SRC emacs-lisp
(add-to-list 'ispell-skip-region-alist '("^http" . "\\]"))
#+END_SRC

Verbatim

#+BEGIN_SRC emacs-lisp
(add-to-list 'ispell-skip-region-alist '("=.*" . ".*="))
#+END_SRC

Bold text list items.

#+BEGIN_SRC emacs-lisp
(add-to-list 'ispell-skip-region-alist '("- \\*.+" . ".*\\*: "))
#+END_SRC

Export properties.

#+BEGIN_SRC emacs-lisp
(defun help/ispell-org-header-lines-regexp (h)
  "Help ispell ignore org header lines."
  (interactive)
  (cons (concat "^#\\+" h ":") ".$"))

(defun help/ispell-a2isra (block-def)
  "Add to the ispell skip region alist the BLOCK-DEF."
  (interactive)
  (add-to-list 'ispell-skip-region-alist block-def))

(let (void)
  (--each
      '("ATTR_LATEX"
        "AUTHOR"
        "CREATOR"
        "DATE"
        "DESCRIPTION"
        "EMAIL"
        "EXCLUDE_TAGS"
        "HTML_CONTAINER"
        "HTML_DOCTYPE"
        "HTML_HEAD"
        "HTML_HEAD_EXTRA"
        "HTML_LINK_HOME"
        "HTML_LINK_UP"
        "HTML_MATHJAX"
        "INFOJS_OPT"
        "KEYWORDS"
        "LANGUAGE"
        "LATEX_CLASS"
        "LATEX_CLASS_OPTIONS"
        "LATEX_HEADER"
        "LATEX_HEADER_EXTRA"
        "OPTIONS"
        "SELECT_TAGS"
        "STARTUP"
        "TITLE")
    (help/ispell-a2isra (help/ispell-org-header-lines-regexp it))))
#+END_SRC

** Sudo

Configure Sudo with Ido.

#+BEGIN_SRC emacs-lisp
(help/on-osx
 (defun help/ido-find-file (&rest args)
   "Find file as root if necessary.

Attribution: SRC `http://emacsredux.com/blog/2013/04/21/edit-files-as-root/'"
   (unless (and buffer-file-name
              (file-writable-p buffer-file-name))
     (find-alternate-file (concat "/sudo:root@localhost:" buffer-file-name))))

 (advice-add 'ido-find-file :after #'help/ido-find-file))
#+END_SRC

** Syntax Checking

Perform syntactic analysis all the time.

#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :ensure t
  :config
  (add-hook 'after-init-hook #'global-flycheck-mode)
  :diminish flycheck-mode)
#+END_SRC

** TAB

Most modes in this system will never use TAB.

#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
#+END_SRC

Remove TAB from all buffers before persisting to the backing file unless it is
configured to retain TAB. The use case is a Makefile.

#+BEGIN_SRC emacs-lisp
(defun help/untabify-if-not-indent-tabs-mode ()
  "Untabify if `indent-tabs-mode' is false.

Attribution: URL `http://www.emacswiki.org/emacs/UntabifyUponSave'"
  (interactive)
  (when (not indent-tabs-mode)
    (untabify (point-min) (point-max))))

(add-hook #'before-save-hook #'help/untabify-if-not-indent-tabs-mode)
#+END_SRC

Most programing modes indent to 2 spaces. TABs should be the same width.

#+BEGIN_SRC emacs-lisp
(setq-default tab-width 2)
#+END_SRC

** Version Control

Use Magit for Git. The commit log editor uses With-Editor and Server modes.
They are not not diminshed because they are infrequently used.

#+BEGIN_SRC emacs-lisp
(use-package magit
             :ensure t
             :config
             (global-set-key (kbd "s-e") #'help/safb-magit-status))
#+END_SRC

Leave the VC message template empty.

#+BEGIN_SRC emacs-lisp
(eval-after-load 'log-edit
  '(remove-hook 'log-edit-hook 'log-edit-insert-message-template))
#+END_SRC

Git ignore files are text files.

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '(".gitignore$" . text-mode))
#+END_SRC

** Whitespace Management

Make control characters easily visible.

#+BEGIN_SRC emacs-lisp
(use-package whitespace
  :ensure t
  :config
  (setq whitespace-style '(trailing lines tab-mark))
  (setq whitespace-line-column help/column-width)
  (global-whitespace-mode t)
  :diminish whitespace-mode global-whitespace-mode)
#+END_SRC

** Word Wrap

#+BEGIN_SRC emacs-lisp
(use-package visual-line-mode
  :diminish visual-line-mode)
#+END_SRC

* Quiet and Pleasant Appearance
   :PROPERTIES:
   :noweb-ref: Quiet-and-Pleasant-Appearance
   :END:

Configure EMACS to personal-taste for "noise" and "form".

** Buffer

Give buffers backed by identically named files distinguishable names.

#+BEGIN_SRC emacs-lisp
(use-package uniquify)
(setq uniquify-buffer-name-style 'forward)
#+END_SRC

Don't use audible bells, use visual bells.

#+BEGIN_SRC emacs-lisp
(setq ring-bell-function 'ignore)
(setq visible-bell t)
#+END_SRC

Highlight s-expressions.

#+BEGIN_SRC emacs-lisp
(setq blink-matching-paren nil)
(show-paren-mode)
(setq show-paren-delay 0)
(setq show-paren-style 'expression)
#+END_SRC

The cursor should not blink and distract you. On a graphic display make the
cursor a box and stretch it as wide as the character below it.

#+BEGIN_SRC emacs-lisp
(blink-cursor-mode 0)
(help/on-gui
 (setq-default cursor-type 'box)
 (setq x-stretch-cursor 1))
#+END_SRC

EMACS used UTF-8 by default. Make copying and pasting easier.

#+BEGIN_SRC emacs-lisp
(prefer-coding-system 'utf-8)
(help/on-gui
 (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
 (help/on-windows
  (set-clipboard-coding-system 'utf-16le-dos)))
#+END_SRC

Make it very easy to see the line with the cursor.

#+BEGIN_SRC emacs-lisp
(global-hl-line-mode t)
#+END_SRC

** Color Theme

The Solarized theme is the perfect theme for everything. bozhidar's
release. It is soft and gentle yet easy to read in any situation.

#+BEGIN_SRC emacs-lisp
(use-package solarized-theme
  :ensure t
  :config
  (setq solarized-distinct-fringe-background t)
  (setq solarized-high-contrast-mode-line t)
  (setq solarized-use-less-bold t)
  (setq solarized-use-more-italic nil)
  (setq solarized-emphasize-indicators nil)
  (load-theme 'solarized-dark t))
#+END_SRC

** Comint

=comint-mode= is only maybe the second most important thing for making Emacs
really, really special.

#+begin_src emacs-lisp
(setq comint-scroll-to-bottom-on-input 'this)
(setq comint-scroll-to-bottom-on-output 'others)
(setq comint-move-point-for-output 'others)
(setq comint-show-maximum-output t)
(setq comint-scroll-show-maximum-output t)
(setq comint-move-point-for-output t)
#+end_src

This configuration had been working fine for a long time. The intent was for it
to be crystal clear that the prompt line in comint buffers would be read only.
This turned out to be a mistake; though I am not sure why, when, or how it
became a mistake. Nonetheless, this should be left alone. The way the issue here
manifested was that all ℝ buffers opened by =ess= were 100% read only which
obviously is a *big issue* if you actually want to use! ROFL

#+BEGIN_SRC emacs-lisp
(setq comint-prompt-read-only nil)
#+END_SRC

** Font

The best programming font is Deja Vu Sans Mono because it sans-serif and
support a lot of Unicode characters. Set it to a good default for an 80
character wide buffer and make it easy to adjust it.

#+BEGIN_SRC emacs-lisp
(help/on-gui
 (defvar help/font-size 10 "The preferred font size.")
 (help/on-osx (setq help/font-size 17))
 (help/on-windows (setq help/font-size 13))
 (defconst help/font-base "DejaVu Sans Mono" "The preferred font name.")
 (defun help/font-ok-p ()
   "Is the configured font valid?"
   (interactive)
   (member help/font-base (font-family-list)))
 (defun help/font-name ()
   "Compute the font name and size string."
   (interactive)
   (let* ((size (number-to-string help/font-size))
          (name (concat help/font-base "-" size)))
     name))
 (defun help/update-font ()
   "Updates the current font given configuration values."
   (interactive)
   (if (help/font-ok-p)
       (progn
         (message "Setting font to: %s" (help/font-name))
         (set-default-font (help/font-name)))
     (message (concat "Your preferred font is not available: " help/font-base))))
 (defun help/text-scale-increase ()
   "Increase font size"
   (interactive)
   (setq help/font-size (+ help/font-size 1))
   (help/update-font))
 (defun help/text-scale-decrease ()
   "Reduce font size."
   (interactive)
   (when (> help/font-size 1)
     (setq help/font-size (- help/font-size 1))
     (help/update-font)))
 (help/update-font))
#+END_SRC

** Frame

The scroll-bars are helpful for new users.

#+BEGIN_SRC emacs-lisp
(scroll-bar-mode 0)
#+END_SRC

The tool-bar is helpful for new users. Isn't the argument funny?

#+BEGIN_SRC emacs-lisp
(tool-bar-mode -1)
#+END_SRC

** Pointer

Hide the pointer when typing.

#+BEGIN_SRC emacs-lisp
(setq make-pointer-invisible t)
#+END_SRC

** Version Control

Provide VC file status indicators.

#+BEGIN_SRC emacs-lisp
(use-package diff-hl
  :ensure t)
#+END_SRC

** Window

Menu bars make EMACS more accessible to non-EMACS users.

#+BEGIN_SRC emacs-lisp
(menu-bar-mode t)
#+END_SRC

Easily return to previous configurations.

#+BEGIN_SRC emacs-lisp
(winner-mode t)
#+END_SRC

* Principle of Least Astonishment (POLA)
  :PROPERTIES:
  :noweb-ref: Principle-of-Least-Astonishment
  :END:

EMACS can load 3 different representations of a Emacs-Lisp source file code
OOTB. The name of source code file is the value before the file extension. When
you pass ~load~ a name it searches for an acceptable representation. Representation
types are indicated by their extension name. =.el= is a human readable and
uncompiled. =.elc= is not human readable and compiled. =.gz= is Gzip compressed and
contains =.el= or =.elc= files.

The variable ~load-suffixes~ determines the order for which text and byte-code
representations are first searched by extension-name. The variable
~load-file-rep-suffixes~ determines the order for all other extension types.

OOTB, EMACS combines the productivity of REPL style of development with the
speed of compiled code by ~load~'ing byte-code first, text second, and compressed
third. This workflow gives you the fastest code at run-time and lets you
experiment with new features stored in text. When you are ready to use them
every time, you compile them. There is only one downside of this approach: when
you forget that it works this way it can be confusing.

When you forget about that style of system you end up with surprising behavior.
The surprise comes when you forget to compile code and then write new code that
depends on the now old version of that code. After the next build, your system
can break in surprising ways. This violates the Principle of Least Astonishment.

This system values predictability so it does the simplest thing possible: ~load~
searches for the newest representation of a file and uses that one. It assumes
that Sysop has total and complete control over the management of file
representations.

This is the *first* thing that /ought/ to happen in the initialization of *any*
tangled system.

#+BEGIN_SRC emacs-lisp
(setq load-prefer-newer t)
#+END_SRC

* Watch What You Eat
  :PROPERTIES:
  :noweb-ref: Watch-What-You-Eat
  :END:

*Code requiring package-management can only follow this block.*

Before ELPA, I used SVN to manage software packages for EMACS. After ELPA,
I used ELPA-packages. Now this system uses MELPA and GNU. MELPA packages always
have their issues fixed very quickly. GNU packages rarely have issues.

Initialize Package.

#+BEGIN_SRC emacs-lisp
(package-initialize)
(add-to-list 'package-archives
             '("melpa" . "http://melpa.org/packages/") t)
(add-to-list 'package-archives
             '("gnu" . "http://elpa.gnu.org/packages/") t)
#+END_SRC

Use-Package is the most configurable and performant way to manage ELPA packages.

Add the Use-Package distribution the load path.

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/src/use-package")
#+END_SRC

Load Use-Package and it's partner Diminish. Every package loaded before this
point uses ~require~. Every package loaded after this point uses ~use-package~.

#+BEGIN_SRC emacs-lisp
(eval-when-compile
  (require 'use-package))
(use-package diminish)
#+END_SRC

* Hacking
** Common Configurations
  :PROPERTIES:
  :noweb-ref: Hacking-Prog*-Mode
  :END:

This system configures ~text-mode~ and ~prog-mode~ very similarly:

- EMACS *exists* to help you work with text.
- EMACS' entire configuration helps you work with text whether it is in a
  specific mode or not.
- Org-Mode's motto is "*Organize Your Life In Plain Text!*".
- From an EMACS and a LP perspective ~text-mode~ *is a* programming mode.
- In this system: *Text is the User-Interface*.

This system does not rely on ~prog-mode~ inheritance to configure it's hacking
modes:

- The EMACS literature advises that modes extend ~text-mode~ or ~prog-mode~
- That /would/ make it easier to configure nearly everything using ~prog-mode-hook~.
- In practice ~prog-mode~ is too new.
- Not all programming modes inherit from it. Not even =IELM= is ready.

With that in mind this system:

- Defines common configuration here for reuse in every desired mode starting
  with =text-mode= and then all logical programming modes.
- Explicitly utilizes it directly instead of using inheritance.
- This system refers to this configuration of programming modes as =prog*-mode=.
- The line between "configuring EMACS", "configuring ~text-mode~", and
  "configuring ~prog*-mode~" is often blurred and sometimes confusing. The lines
  become wavy and intertwined with mastery of EMACS and LP.

*** Text-Mode

- Line numbers make documents easier to read.
- Indicate that Text-Mode buffers ought to be 80 characters wide.
  #+BEGIN_SRC emacs-lisp
(use-package fill-column-indicator
  :ensure t
  :config
  (setq-default fill-column help/column-width))
  #+END_SRC

#+BEGIN_SRC emacs-lisp
(defun help/text-prog*-setup ()
  "HELP's standard configuration for buffer's working with text, often for
   programming."
  (interactive)
  (visual-line-mode)
  (linum-mode)
  (fci-mode)
  (rainbow-mode)
  (help/try-to-add-imenu))

(add-hook #'text-mode-hook #'help/text-prog*-setup)
#+END_SRC

*** Prog*-Mode Modes

- Mode inheritance is represented by list definition & indentation.
- Some modes are so simple that inheritance isn't defined.

- Hacking mode hooks.
  - Configurations common to every hacking vehicle.
    #+BEGIN_SRC emacs-lisp
(setq help/hack-modes '(makefile-mode-hook ruby-mode-hook sh-mode-hook plantuml-mode-hook tex-mode-hook))
    #+END_SRC
  - LISP mode hooks.
    - Are hacking modes.
      #+BEGIN_SRC emacs-lisp
(setq help/hack-lisp-modes
      '(emacs-lisp-mode-hook
        ielm-mode-hook
        lisp-interaction-mode))
(setq help/hack-modes (append help/hack-modes help/hack-lisp-modes))
      #+END_SRC
    - IELM mode hook.
      - Does one or two more things.

*** Prog*-Mode Hook

**** Goal

- Indent at every opportunity and automatically. Verify that it makes sense
  for the mode. Explicitly define instead of relying on ~prog-mode~ inheritance;
  use this documents logical ~prog*-mode~ approach instead.
  #+BEGIN_SRC emacs-lisp
(use-package aggressive-indent
  :ensure t
  :config)
  #+END_SRC
- Always maintain balanced brackets. Easily wrap the selected region. Auto-escape
  strings pasted into other strings. Smartparens provides built-in correct
  behavior for most modes.
  #+BEGIN_SRC emacs-lisp
(use-package smartparens-config
  :ensure smartparens
  :config
  (setq sp-show-pair-from-inside nil)
  (eval-after-load "smartparens-mode"
    '(diminish 'smartparens-mode)))
  #+END_SRC

**** Implementation.

#+BEGIN_SRC emacs-lisp
(defun help/hack-prog*-mode-hook-fn ()
  (interactive)
  (help/text-prog*-setup)
  (smartparens-strict-mode)
  (aggressive-indent-mode)
  (hs-minor-mode)
  (help/not-on-gui (local-set-key (kbd "RET") #'newline-and-indent))
  (help/on-gui (local-set-key (kbd "<return>") #'newline-and-indent)))
#+END_SRC

*** Wiring

 #+BEGIN_SRC emacs-lisp
(let (void)
  (--each help/hack-modes
    (add-hook it #'help/hack-prog*-mode-hook-fn)))

(let (void)
  (--each help/hack-lisp-modes
    (add-hook it #'help/emacs-lisp-mode-hook-fn)))

(add-hook #'ielm-mode-hook #'help/ielm-mode-hook-fn)
 #+END_SRC

** (Literate Programming)
** Emacs Lisp
  :PROPERTIES:
  :noweb-ref: Hacking-Emacs-Lisp
  :END:

#+BEGIN_SRC emacs-lisp
(setq initial-scratch-message nil)
(use-package lexbind-mode)

(defun help/elisp-eval-buffer ()
  "Intelligently evaluate an Elisp buffer."
  (interactive)
  (help/save-all-file-buffers)
  (eval-buffer))

(defun endless/sharp ()
  "Insert #' unless in a string or comment.

RC: URL `http://endlessparentheses.com/get-in-the-habit-of-using-sharp-quote.html?source=rss'"
  (interactive)
  (call-interactively #'self-insert-command)
  (let ((ppss (syntax-ppss)))
    (unless (or (elt ppss 3)
                (elt ppss 4))
      (insert "'"))))

(defun help/elisp-mode-local-bindings ()
  "Helpful behavior for Elisp buffers."
  (local-set-key (kbd "s-l eb") #'help/elisp-eval-buffer)
  (local-set-key (kbd "s-l ep") #'eval-print-last-sexp)
  (local-set-key (kbd "s-l td") #'toggle-debug-on-error)
  (local-set-key (kbd "s-l mef") #'macroexpand)
  (local-set-key (kbd "s-l mea") #'macroexpand-all)
  (local-set-key (kbd "s-:") #'my-eval-expression)
  (local-set-key (kbd "#") #'endless/sharp))

(defun help/emacs-lisp-mode-hook-fn ()
  (interactive)
  (help/elisp-mode-local-bindings)
  (lexbind-mode)
  (turn-on-eldoc-mode)
  (diminish 'eldoc-mode))

(setq ielm-noisy nil)

(setq ielm-prompt "𝔼LISP> ")

(setq ielm-dynamic-return nil)

(setq ielm-dynamic-multiline-inputs nil)

(defun help/ielm-mode-hook-fn ()
  "HELP customizations."
  (interactive)
  (help/ielm-auto-complete))
#+END_SRC

*** Keybinding

#+BEGIN_SRC emacs-lisp
(define-key emacs-lisp-mode-map (kbd "s-p") #'describe-thing-in-popup)
#+END_SRC

** Org Mode
  :PROPERTIES:
  :noweb-ref: Hacking-Org-Mode
  :END:

When source blocks are evaluated, their results get stored in a result area,
typically for display. If the results are small, they are displayed with colons
instead of an =example= block. Instead, *always* place them in an
example block. This makes exports more consistent and other Org-Mode features seem
to behave more predictably.

#+BEGIN_SRC emacs-lisp
(setq org-babel-min-lines-for-block-output 0)
#+END_SRC

When Source-Block evaluation results are inserted try to use the name or cache-id.
If neither are present, the =RESULTS= block becomes a =NAME= "results" block.

#+BEGIN_SRC emacs-lisp
(setq org-babel-results-keyword "NAME")
#+END_SRC

Configure Org-Mode to manage it's Source-Block backed buffers the same as the
rest of this system.

#+BEGIN_SRC emacs-lisp
(setq org-edit-src-auto-save-idle-delay 0)
(setq org-edit-src-turn-on-auto-save nil)
#+END_SRC

Update in-buffer images after Source-Block execution. This is a programming task.
That is why it is under this heading and Evaluation. This is a setting configuring
how the results of evaluation are refreshed in EMACS.

#+BEGIN_SRC emacs-lisp
(defun help/org-babel-after-execute-hook ()
  "HELP settings for the `org-babel-after-execute-hook'.

This does not interfere with exports.

Attribution: URL `https://lists.gnu.org/archive/html/emacs-orgmode/2015-01/msg00534.html'"
  (interactive)
  (org-redisplay-inline-images))

(add-hook 'org-babel-after-execute-hook 'help/org-babel-after-execute-hook)
#+END_SRC

Never "automatically" evaluate a source block.

#+BEGIN_SRC emacs-lisp
(setq org-confirm-babel-evaluate nil)
#+END_SRC

Make it unpleasant for Sysop to modify source-block outside of a source-block
backed buffer. The next step is to write some code to prevent modifying
source-blocks outside of that place.

#+BEGIN_SRC emacs-lisp
(setq org-src-tab-acts-natively nil)
#+END_SRC

My personal TODO workflow.

#+BEGIN_SRC emacs-lisp
(setq org-todo-keywords
      '((sequence "TODO" "IN-PROGRESS" "BLOCKED" "REVIEW" "DONE")))
#+END_SRC

When running in a GUI, I would like linked images to be displayed inside of
Emacs.

#+BEGIN_SRC emacs-lisp
(setq org-startup-with-inline-images (display-graphic-p))
#+END_SRC

Use Ido completion in Org-Mode.

#+BEGIN_SRC emacs-lisp
(setq org-completion-use-ido t)
(setq org-outline-path-complete-in-steps nil)
(setq org-completion-use-iswitchb nil)
#+END_SRC

Org-Mode lets you use single letter commands to do stuff on headers. I like to
use =c= for cycling the header expansion.

#+BEGIN_SRC emacs-lisp
(setq org-use-speed-commands t)
#+END_SRC

Ask before execution of shell links. This might seem like an Evaluation
activity. It is. It is interactive.

#+BEGIN_SRC emacs-lisp
(setq org-confirm-shell-link-function 'y-or-n-p)
#+END_SRC

Ask before execution of Emacs-Lisp.

#+BEGIN_SRC emacs-lisp
(setq org-confirm-elisp-link-function 'y-or-n-p)
#+END_SRC

Make sure that incomplete TODO entries prevent the enclosing parent from every
turning to DONE.

#+BEGIN_SRC emacs-lisp
(setq org-enforce-todo-dependencies t)
#+END_SRC

Allow the mouse to do Org-Mode things like expand and collapse headings.

#+BEGIN_SRC emacs-lisp
(when (display-graphic-p)
  (use-package org-mouse))
#+END_SRC

Use a real ellipsis to render an ellipsis for Org-Mode stuff like showing that a
header is collapsed.

#+BEGIN_SRC emacs-lisp
(setq org-ellipsis "…")
#+END_SRC

It is easy to see indentation of headlines without having to count asterisks, so
don't show them, only show the significant and last one.

#+BEGIN_SRC emacs-lisp
(setq org-hide-leading-stars t)
#+END_SRC

Display emphasized text as you would in a WYSIWYG editor.

#+BEGIN_SRC emacs-lisp
(setq org-fontify-emphasized-text t)
#+END_SRC

Use Unicode characters to visualize things like right arrow eg \rarr . Most of those
symbols are correctly exported to the destination format. The most obvious is
this example in LaTeX versus Text.

#+BEGIN_SRC emacs-lisp
(setq org-pretty-entities t)
#+END_SRC

Highlight LaTeX and related markup.

Normally, I don't do any syntax highlighting, as I believe that should be
delegated to source buffers, thinking that to do otherwise is distracting.
However, I already do configure subscripts and Greek letters to be displayed
with syntax highlighting, because I want to indicate to the human reader that
they are special, and specifically /not/-Unicode. Do the same thing for LaTeX
and related markup.

#+BEGIN_SRC emacs-lisp
(setq org-highlight-latex-and-related '(latex script entities))
#+END_SRC

Allow "refactoring" of Footnotes between documents.

#+BEGIN_SRC emacs-lisp
(setq org-footnote-define-inline t)
(setq org-footnote-auto-label 'random)
(setq org-footnote-auto-adjust nil)
(setq org-footnote-section nil)
#+END_SRC

This is an amazingly easy way to screw up your document. The more you edit
org docs, the more you realize how you must truly protect it.

#+BEGIN_SRC emacs-lisp
(setq org-catch-invisible-edits 'error)
#+END_SRC

Though I am not delving deep, it is hard not to want to customize some stuff
and perhaps this is the start. Even though I enabled this, I don't think that I
ever used it.

#+BEGIN_SRC emacs-lisp
(setq org-loop-over-headlines-in-active-region t)
#+END_SRC

It is /almost always/ faster to work with org documents when they are fully
expanded. Anyway, the structure cycling makes it really, really easy to get an
/outline view/ again.

#+BEGIN_SRC emacs-lisp
(setq org-startup-folded "nofold")
#+END_SRC

When images are displayed in the buffer, display them in their actual size. As
the operator, I want to know their true form. Any modifications required for
export will be stated explicitly.

#+BEGIN_SRC emacs-lisp
(setq org-image-actual-width t)
#+END_SRC

Hide the delimeter for emphasized text. Unicode characters break table
alignment.

#+BEGIN_SRC emacs-lisp
(setq org-hide-emphasis-markers t)
#+END_SRC

Realign tables automatically.

#+BEGIN_SRC emacs-lisp
(setq org-startup-align-all-tables t)
#+END_SRC

Always use Unicode checkboxes.

#+BEGIN_SRC emacs-lisp
(setq org-html-checkbox-type 'unicode)
#+END_SRC

You may display syntax highlighting for code in source blocks. I don't.

#+BEGIN_SRC emacs-lisp
(setq org-src-fontify-natively nil)
#+END_SRC

Never indent the contents of a source-block automatically.

#+BEGIN_SRC emacs-lisp
(setq org-edit-src-content-indentation 0)
#+END_SRC

When edit mode is exited, the option exists to automatically remove empty
opening and closed lines for the source block. Never do this. The thing is that
I forgot why. When I was working on a recent analysis with ℝ there was a
space appearing in the opening and closing line of the source block that didn't
appear in the source editing buffer. That surprised me. I am sure that I've
forgotten why this is the case. I don't like it because you add a bunch of
empty lines in the source buffer for every source block. With that in mind I
will enable this feature and try it out again.

#+BEGIN_SRC emacs-lisp
(setq org-src-strip-leading-and-trailing-blank-lines t)
#+END_SRC

The source block buffer may be configured to appear in a few different places.
For a while I really liked =reorganize-frame= because sometimes you want to be
able to see the code you are editing in edition to the rest of the document. At
least that is what I am telling myself. Once I learned you could change it I
realized that 1 I should have asked if it could be changed and 2 I should have
changed it. The flow that I've got configured here is that you are either in the
source document where code blocks are not highlighted or you are in the source
block so you are editing in a buffer that is full-fledged HELP. That is the best
way so you can focus completely on each task at hand in the ideal mode for that
task. Anything else results in distractions and errors.

#+BEGIN_SRC emacs-lisp
(setq org-src-window-setup 'current-window)
#+END_SRC

Org-Mode has a really nice feature that hitting =C-c C-c= will generally just do
the /right thing/. It is really nice. That feature extends to source blocks of
course. Ironically I had a typo here, typing /of curse/ instead of /of course/.
The thing is that you really, really need to develop a personal workflow, and
then configure the tool to enable it. The more I learn about Org-Mode, the more
leery I am about making it really easy to evaluate code. I want it to be a
really, really specific and decided action to evaluate a code block, so don't
make it so easy as =C-c C-c=.

#+BEGIN_SRC emacs-lisp
(setq org-babel-no-eval-on-ctrl-c-ctrl-c t)
#+END_SRC

Configure the system to successfully use ~vc-next-action~ while editing a
Source-Block. Before perfoming the edit, check if it is Org-Mode and
exit the Source-Block Buffer (SBB). If this system stays in the SBB
when calling ~vc-next-action~ the entire contents of the buffer are escaped
as Org-Mode source code upon returning to the source buffer (this).

#+BEGIN_SRC emacs-lisp
(defun help/vc-next-action ()
  "If in org source block, exit it before `vc-next-action'."
  (interactive)
  (when (condition-case nil
            (org-src-in-org-buffer)
          (error nil))
    (org-edit-src-exit))
  (vc-next-action nil))
#+END_SRC

Never use the original version.

#+BEGIN_SRC emacs-lisp
(setq org-edit-src-code nil)
#+END_SRC

Easily markup text in Org-Mode. This is not used by the rest of HELP because
Smartparens provides that functionality.

#+BEGIN_SRC emacs-lisp
(use-package wrap-region
  :ensure t
  :config
  :diminish wrap-region-mode)
#+END_SRC

*Bold*.

#+BEGIN_SRC emacs-lisp
(wrap-region-add-wrapper "*" "*" nil 'org-mode)
#+END_SRC

/Italic/.

#+BEGIN_SRC emacs-lisp
(wrap-region-add-wrapper "/" "/" nil 'org-mode)
#+END_SRC

=Verbatim=.
#+BEGIN_SRC emacs-lisp
(wrap-region-add-wrapper "=" "=" nil 'org-mode)
#+END_SRC

~Code~.

#+BEGIN_SRC emacs-lisp
(wrap-region-add-wrapper "~" "~" nil 'org-mode)
#+END_SRC

+Strike-Through+.
#+BEGIN_SRC emacs-lisp
(wrap-region-add-wrapper "+" "+" nil 'org-mode)
#+END_SRC

*** Keybindings

Started questioning why after hitting RETURN while in lists I have to hit TAB to
get indented properly. Kind of a dead giveaway that I should be
return-and-indenting! Looked at =org-return= to find that it has an argument
about indenting and then saw that =org-return-indent= passes it for you. With that
in mind, RETURN is bound to that now. Now HELP has four different kinds of
"returns" in Org in order of likelihood of usage:

- org-return-indent :: Make it really easy to work in existing list items,
  headings, and tables
  - This is listed first because I often go back to modify entries
  - <return> because it is used the most
- org-meta-return :: Make it really easy to add new list items, headings, and
  table contents
  - M-<return> because the binding comes with Org
- electric-indent-just-newline :: For when I want to break out of the default
  Org indentation to start working at the beginning of the line for example when
  I'm done working in a list or have just created a new heading
  - C-M-<return> because it is next step "lower" in the binding
- help/smart-open-line :: When I want to insert a new line between the current
  and next line then position the cursor correctly indented at the start of it.
  - s-<return> because it is that is the last place in the modifier key chain

#+BEGIN_SRC emacs-lisp
(help/not-on-gui
 (define-key org-mode-map (kbd "RET") 'org-return-indent)
 (define-key org-mode-map (kbd "C-M-RET") 'electric-indent-just-newline))
(help/on-gui
 (define-key org-mode-map (kbd "<return>") 'org-return-indent)
 (define-key org-mode-map (kbd "C-M-<return>") 'electric-indent-just-newline))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(define-key org-mode-map (kbd "s-j") #'org-babel-next-src-block)
(define-key org-mode-map (kbd "s-u") #'org-goto)
(define-key org-mode-map (kbd "s-U") #'org-mark-ring-goto)
(define-key org-mode-map (kbd "s-k") #'org-babel-previous-src-block)
(define-key org-mode-map (kbd "s-i") #'help/safb-org-babel-tangle)
(define-key org-mode-map (kbd "s-l") #'help/safb-org-edit-src-code)
(define-key org-mode-map (kbd "s-o") #'org-babel-execute-maybe)
(define-key org-mode-map (kbd "s-;") #'org-babel-view-src-block-info)
(define-key org-mode-map (kbd "s-p") #'org-babel-demarcate-block)
#+END_SRC

Safe all buffers before working with Exports.

#+BEGIN_SRC emacs-lisp
(define-key org-mode-map (kbd "C-c C-e") #'help/safb-org-export-dispatch)
#+END_SRC

Make =s-l= do the same thing to leave the Source-Block-Buffer.

#+BEGIN_SRC emacs-lisp
(define-key org-src-mode-map (kbd "s-l") #'org-edit-src-exit)
#+END_SRC

Easily enter guillemots.

#+BEGIN_SRC emacs-lisp
(key-chord-define org-src-mode-map "<<" (lambda () (interactive) (insert "«")))
(key-chord-define org-src-mode-map ">>" (lambda () (interactive) (insert "»")))
#+END_SRC
** (Applied Mathematics)
** Emacs Speaks Statistics (ESS) [fn:3bba0c0c: http://ess.r-project.org/] [fn:25441790: https://en.wikipedia.org/wiki/Emacs_Speaks_Statistics] [fn:a2ae633d: http://www.emacswiki.org/emacs/EmacsSpeaksStatistics] [fn:b28cb112: http://blog.revolutionanalytics.com/2011/08/ess.html] [fn:353ffc35: http://blog.revolutionanalytics.com/2014/03/emacs-ess-and-r-for-zombies.html] [fn:3b20a6da: https://rstudio-pubs-static.s3.amazonaws.com/2246_6f220d4de90c4cfda4109e62455bc70f.html]
This section takes about 15 seconds to tangle.

Get =ESS= loaded before doing anything with it in here or out there.

#+BEGIN_SRC emacs-lisp
(require 'ess-site)
#+END_SRC

For a minimalist release history, read the news file [fn:7be08525: http://ess.r-project.org/Manual/news.html].

For a brief, brief overview and release history, read the readme [fn:1b644ec0: http://ess.r-project.org/Manual/readme.html].

For a comprehensive overview, read the manual [fn:adfd9a4c: http://ess.r-project.org/Manual/ess.html].

In it:
- 𝕊 refers to any language in the family.
  - ℝ is what I'm interested in.
- First 2.5 pages do some nice expectation-setting.
- Generally seems like a highly rich development environment with support for
  editing, debugging, and support with everything that you would expect from
  the best of Emacs.
- Manual covers most requested variables for configuring, but the customize
  facility covers more, and mentions that either way you should avoid doing so
  until you have used =ESS= for a while.
- Check that =ess= is installed with a call to =ess-version=.

#+BEGIN_SRC emacs-lisp
(defconst gcr/ess-version "14.11")

(defun gcr/warn-ess-version ()
  "Warn of ess misconfiguration."
  (interactive)
  (when (not (version= ess-version gcr/ess-version))
    (warn "Insufficient ess-mode requirements. Expected %S. Found: %S " gcr/ess-version ess-version)))
(gcr/warn-ess-version)
#+END_SRC

ℝ first notes:
- ℝ will start ℝ via =Emacs=
- Multiple =ESS= processes may run simultaneously, and may be selected by a
  specific language via their buffer name that has a number appended, or may be
  accessed via a menu using =ess-request-a-process=.
- =ESS= works transparently on remote machines using =TRAMP= to manage a remote
  ℝ instance. An example is provided for Amazon. Means exist for supporting remote
  graphical displays or redirecting to a file. Excellent support seems to exist
  to quite flexibly support unexpected things like starting an =ESS= supported
  program in a plain old shell and being able to convert it to an =ESS= supported
  buffer.

Various user interaction stuff:
- Return sends the input from wherever you hit return, nice.
- =M-{= and =M-}= cycle through commands you ran
- =M-h= select a whole "paragraph", a block in their terms
- =C-x [= moves through the previous ESS sessions, =C-x ]= forward.
- =C-c C-p= and =C-c C-n= cycle through previous commands.
  - How is this different than the other one?
- =C-c RET= copies an old command to the prompt without running it
  - Great idea
- Keep your session transcript pruned
  - =ess-transcript-clean-region= removes non-commands from a transcript for you
- Previous command look-up can be done by completion via =comint-*-matching=.
  - =M-p= and =M-n= seem to work just fine though.
- Previous command execution, by name, offset, or just the last one, are by =!=
  - This feature is actually quite rich and a real regexen style system.

Always show eldoc for ℝ stuff, everywhere it may.
#+BEGIN_SRC emacs-lisp
(setq ess-eldoc-show-on-symbol t)
#+END_SRC

Various session interaction stuff
- Show objects in the work-space: =C-c C-x=
- Search for what libraries are available to the work-space: =C-c C-s=
- Load file with source: =C-c C-l=
- Visit errors: =C-c '= and =C-x '=
- Show help on an object: =C-c C-v=
- Quit: =C-c C-q=
- Abort: =C-c C-c=
- Switch between the console and the most recent file buffer: =C-c C-z=

Sending code to the ESS process
- =ess-eval-region-or-line-and-step=: Eval the region, or the line, move to next
  line
- =C-M-x=: Eval the current region, function, or paragraph
- =C-c C-c=: Do that and then go to the next line
- =C-c C-j=: Eval the current line
- =C-c M-j=: Eval line and jump to the console
- =C-c C-f=: Eval the currently selected function
- =C-c M-f=: Eval the currently selected function and jump to the console
- =C-c C-r=: Eval the region
- =C-c M-r=: Eval the region and jump to the console
- =C-c C-b=: Eval the buffer
- =C-c M-b=: Eval the buffer and jump to the console
- You can do all this stuff from transcript files, too.
  - My thought is that I never, ever will and if I do need to, I'm looking up the
    commands again as I don't want to make a habit of doing that kind of
    thing (running old transcripts).

Editing objects and functions:
- =C-c C-e C-d=: Edit the current object
- =C-c C-l=: Load source file into the ESS process
- =TAB= Indents/re-formats or completes code.
- =M-;=: Correctly indents the current comment

Help mode inside of ESS:
- =C-c C-v=: =ess-display-help-on-object=: Get help on anything
- =?=: Show commands available in help mode
- =h=: Show help for a different object. Currently focused object defaults.
- =n= and =p=: Cycle through sections
- =l=: Eval the current line in the console; usually sample code.
- =r=: Eval current region, too
- =q=: Quit out of that buffer
- =k=: Kill that buffer
- =x=: Kill that buffer and return to ESS
- =i=: Get info on a package
- =v=: Show vignettes
- =w=: Show current help page in browser

Completion:
- =TAB=: Complete anything
- =M-?=: Show completions available
- =ess-resynch=: Refreshes the completion cache

*ess-tracebug* start

#+BEGIN_SRC emacs-lisp
(setq ess-use-tracebug t)
#+END_SRC

For all =ess-tracebug= stuff, the map prefix is =C-c C-t=

<2014-11-11 Tue>
The documentation for =ess-tracebug-help= provides all of this documentation that
I copied from the website into here. Someday I should clean this up!

Breakpoints =ess-dev-map=:
- b =ess-bp-set= :: Set BP (repeat to cycle BP type)
- B =ess-bp-set-conditional= :: Set conditional BP
- k =ess-bp-kill= :: Kill BP
- K =ess-bp-kill-all= :: Kill all BPs
- o =ess-bp-toggle-state= :: Toggle BP state
- l =ess-bp-set-logger= :: Set logger BP
- n =ess-bp-next= :: Goto next BP
- p =ess-bp-previous= :: Goto previous BP

Note: =C-= prefixed equivalents are also defined

Debugging =ess-dev-map=:
- ` =ess-show-traceback= (also on C-c ) :: Show traceback
- ~ =ess-show-call-stack= (also on C-c ~) :: Show callstack
- e =ess-debug-toggle-error-action= :: Toggle error action (repeat to cycle)
- d =ess-debug-flag-for-debugging= :: Flag for debugging
- u =ess-debug-unflag-for-debugging= :: Unflag for debugging
- w =ess-watch= :: Watch window

Note: =C-= prefixed equivalents are also defined)

Interactive Debugging =ess-debug-minor-mode-map=:
- M-C =ess-debug-command-continue= :: Continue
- M-C-C =ess-debug-command-continue-multi= :: Continue multi
- M-N =ess-debug-command-next= :: Next step
- M-C-N =ess-debug-command-next-multi= :: Next step multi
- M-U =ess-debug-command-up= :: Up frame
- M-Q =ess-debug-command-quit= :: Quit debugging

Navigation to errors (general Emacs functionality):
- =C-x `=, =M-g n :: =next-error=
- =M-g p= :: =previous-error=

*ess-tracebug* stop

- Be sure to specify this per-project.
#+BEGIN_SRC emacs-lisp
(setq ess-tracebug-search-path '())
#+END_SRC

- Make error navigation simpler
#+BEGIN_SRC emacs-lisp
(define-key compilation-minor-mode-map [(?n)] 'next-error-no-select)
(define-key compilation-minor-mode-map [(?p)] 'previous-error-no-select)
#+END_SRC

- The font size for watched variables.
#+BEGIN_SRC emacs-lisp
(setq ess-watch-scale-amount -1)
#+END_SRC

Data viewing:
- *Never* rely upon on the REPL for data viewing
  - Will mix up exploratory code with data
    - Can't easily distinguish between code and data
    - Distracting you
    - Breaking your flow
- Sometimes
  - You end up somewhere
    - And the =ess= buffer cursor is at the top!
    - No problem, call =ess-switch-to-end-of-ESS=
- Make it easier to know what object values are.
  - =ess-describe-object-at-point=
#+BEGIN_SRC emacs-lisp
(setq ess-describe-at-point-method 'tooltip)
#+END_SRC
- Visualize just about anything.
  - =ess-R-object-popup=
#+BEGIN_SRC emacs-lisp
(require 'ess-R-object-popup)
#+END_SRC
- Rdired is another way to work with object
  - =ess-rdired=
  - View, delete, plot, and update buffer (ala /revert/) are single key commands
#+BEGIN_SRC emacs-lisp
(autoload 'ess-rdired "ess-rdired")
#+END_SRC
- Visualize data frames better.
  - =ess-R-dv-ctable=
  - =ess-R-dv-pprint=
#+BEGIN_SRC emacs-lisp
(require 'ess-R-data-view)
#+END_SRC
- inlineR
  - /Not/ a competitor to =org-mode=
  - Ultra lightweight LP, really
#+BEGIN_SRC emacs-lisp
(require 'inlineR)
#+END_SRC

Documentation:
- Whole section on native documentation; I'll re-visit as needed.
- Roxygen, too.

=ess-developer= helps you to easily work within specific name-spaces.

Rutils: key-bindings to aid real usage
- =C-c C-. l=: List all packages in all available libraries.
- =C-c C-. r=: List available packages from repositories listed by =getOptions(‘‘repos’’)=
in the current R session.
- =C-c C-. u=: Update packages in a particular library lib and repository repos.
- =C-c C-. a=: Search for a string using apropos.
- =C-c C-. m=: Remove all R objects.
- =C-c C-. o=: Manipulate R objects; wrapper for =ess-rdired=.
- =C-c C-. w=: Load a workspace file into R.
- =C-c C-. s=: Save a work-space file.
- =C-c C-. d=: Change the working directory for the current R session.
- =C-c C-. H=: Use =browse-url= to navigate R HTML documentation.

=ess-mode-silently-save= is worth a million bucks; usually I have to hand code
this.

As of <2014-01-31 Fri>, you need to manually load ESS when you pull it from
MELPA [fn:8dece4ca: https://stat.ethz.ch/pipermail/ess-help/2014-January/009705.html]. That is totally fine with me, that is really the best way to load stuff.
Out of curiosity, I read more about it here [fn:c5cac42b: https://github.com/milkypostman/melpa/issues/6], but that occurred before
this previous post made by the maintainers. Even the source code in
=ess-autoloads.el= has a license from 2012, which is before the aforementioned
post. As such, this configuration step seems correct and necessary for now.
Additionally, this how the user manual expects a typical manual setup to be
configured.

Looked a tiny bit at how R hackers are formatting their code [fn:9039b33e: https://google-styleguide.googlecode.com/svn/trunk/Rguide.xml] [fn:da0df786: http://adv-r.had.co.nz/Style.html].
The simple (dumb) part of me suspects that C++ formatting is generally just fine [fn:5b466d0c: https://stackoverflow.com/questions/7502540/make-emacs-ess-follow-r-style-guide].

There is strangely nice discussion about where temp files may be stored;
specifically for cases where you edit identically-named objects and want to keep
them in the same directory but per-project. That is not the need now, and it is
nice to know that it is an option.

Store history files and dump files in a single known location. If that location
doesn't exist, then make it.
#+BEGIN_SRC emacs-lisp
(setq gcr/r-dir "~/.R/")
(defun gcr/make-warn-R-dir ()
  "Handle of R directory misconfiguration."
  (interactive)
  (unless (f-directory? gcr/r-dir)
    (progn
      (message "Couldn't find %S… creating it." gcr/r-dir)
      (f-mkdir gcr/r-dir))))
(gcr/make-warn-R-dir)
(setq ess-history-directory gcr/r-dir)
(setq ess-source-directory gcr/r-dir)
#+END_SRC

Since I'm using ℝ for everything, configure /everything/ to be using ℝ.
#+BEGIN_SRC emacs-lisp
(setq inferior-ess-program "R")
(setq inferior-R-program-name "R")
(setq ess-local-process-name "R")
#+END_SRC

Always start =ess= within the curent =emacs= frame, it doesn't need to be separate.
#+BEGIN_SRC emacs-lisp
(setq inferior-ess-same-window nil)
(setq inferior-ess-own-frame nil)
#+END_SRC

Help buffers all belong in the same frame.
#+BEGIN_SRC emacs-lisp
(setq ess-help-own-frame nil)
#+END_SRC

When =ess= starts, or when ℝ starts, it takes the current directory as its
working directory. This is totally fine; so don't ask what the working directory
should be.
#+BEGIN_SRC emacs-lisp
(setq ess-ask-for-ess-directory nil)
#+END_SRC

My preference is for ESS to quit and not ask me whether or not I am sure. There
is an intentional line-break after the closing round bracket because that is the
approach of the original value here.
#+BEGIN_SRC emacs-lisp
(setq inferior-ess-exit-command "q('no')
")
#+END_SRC

When commands are executed, display their output within the current buffer,
rather than to a new dedicated buffer for them.
#+BEGIN_SRC emacs-lisp
(setq ess-execute-in-process-buffer +1)
#+END_SRC

When you cycle between a the ℝ buffer and the script, you get to the process
buffer, you will go to the end of the buffer. This setting is specifically to
handle a buffer that is scrolling when you want to see the last result and will
scroll back after the fact to see the history.
#+BEGIN_SRC emacs-lisp
(setq ess-switch-to-end-of-proc-buffer t)
#+END_SRC

Use typical auto completion in buffers here, but don't do it when the
next char is a symbol or closed paren.
#+BEGIN_SRC emacs-lisp
(setq ess-tab-complete-in-script +1)
(setq ess-first-tab-never-complete 'symbol-or-paren-or-punct)
#+END_SRC

Use =ido= completion whenever possible.
#+BEGIN_SRC emacs-lisp
(setq ess-use-ido t)
#+END_SRC

Handle rdoc and rmd files, though I have never used them… yet.
#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.rd\\'" . Rd-mode))
(add-to-list 'auto-mode-alist '("\\.Rmd$" . r-mode))
#+END_SRC

Use =eldoc= for this mode. Always show it when the point is on a symbol.
Try to keep help strings at 10 chars or less.
#+BEGIN_SRC emacs-lisp
(setq ess-use-eldoc t)
(setq ess-eldoc-show-on-symbol t)
(setq ess-eldoc-abbreviation-style 'normal)
#+END_SRC

Make it really easy to search the ℝ archives for anything.
#+BEGIN_SRC emacs-lisp
(local-set-key (kbd "C-c C-. S") 'ess-rutils-rsitesearch)
#+END_SRC

Make it really easy to do common stuff for ℝ with good keybindings.
#+BEGIN_SRC emacs-lisp
(require 'ess-rutils)
(setq ess-rutils-keys +1)
#+END_SRC

=r-autoyas= does argument completion. I had it working nice, and didn't use it for
a while, and now it doesn't work. This needs some TLC.
#+BEGIN_SRC emacs-lisp
(require 'r-autoyas)

(setq r-autoyas-debug t)
(setq r-autoyas-expand-package-functions-only nil)
(setq r-autoyas-remove-explicit-assignments nil)
#+END_SRC

These functions are metioned, and I am not sure where or how to use them yet,
but Vitalie Spinu mentioned them as being useful:
- =comint-previous-matching-input-from-input=
- =comint-history-isearch-backward-regexp=

Personal customizations for this mode. For some currently unknown reason,
=smartparens= only runs when you call =smartparens-strict-mode= and not
=turn-on-smartparens-strict-mode= like it does everywhere else.

For a while I used =ess-eval-buffer-and-go=, but now I know that it is insanely
faster to use =ess-eval-buffer= instead. Previously I've read people saying that,
and it is true.

Save two spaces showing function information in the mini-buffer.
#+BEGIN_SRC emacs-lisp
(setq ess-ac-R-argument-suffix "=")
#+END_SRC

When I started to standardize arrows across modes, I recalled the =ess=
documentation and was also reminded [fn:645cef99: http://www.r-bloggers.com/a-small-customization-of-ess/]
here how easy it is to customize it.

Not sure where I put the notes, but long ago I researched the ℝ coding
standards. [[http://stackoverflow.com/questions/7502540/make-emacs-ess-follow-r-style-guide][This post]] by Eddelbuettel led me to believe that the ℝ [[http://cran.r-project.org/doc/manuals/R-ints.html#R-coding-standards][standard]]
definition is the best. That made me think that =RRR= would be the best because
it has identical settings to the =C++= style at the time of the post. That makes
sense to me. I only want to change one thing to make Magrittr chains easier to
read. The stock =RRR= indenting makes expressions trail off to the right forever.
Here is how, make a copy of =RRR= and change one property.

#+BEGIN_SRC emacs-lisp
(setq gcr/ess-style
      (copy-alist
       (assoc 'RRR ess-style-alist)))
(setf (nth 0 gcr/ess-style) 'GCR)
(setf (cdr
       (assoc 'ess-continued-statement-offset
              (cdr gcr/ess-style)))
      0)
(add-to-list 'ess-style-alist gcr/ess-style)
(setq ess-default-style 'GCR)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun gcr/ess-mode-hook ()
  (local-set-key (kbd "s-e") 'ess-switch-to-end-of-ESS)
  (local-set-key (kbd "s-x") 'r-autoyas-expand)
  (local-set-key (kbd "s-p") 'ess-R-object-popup)
  (local-set-key (kbd "s-v o") 'ess-describe-object-at-point)
  (local-set-key (kbd "s-v d") 'ess-rdired)
  (local-set-key (kbd "s-v cc") 'ess-R-dv-ctable)
  (local-set-key (kbd "s-v cp") 'ess-R-dv-pprint)
  (local-set-key (kbd "C-.") (lambda () (interactive) (insert " -> ")))
  (local-set-key (kbd "C-M-,") (lambda () (interactive) (insert " <<- ")))
  (local-set-key (kbd "C-M-.") (lambda () (interactive) (insert " ->> ")))
  (key-chord-define-local (kbd ",.") (lambda () (interactive) (insert " %<>% ")))
  (local-set-key (kbd "s-.") (lambda () (interactive) (insert " %>% ")))
  (local-set-key (kbd "C-0") 'ess-eval-buffer)
  (turn-on-pretty-mode)
  (r-autoyas-ess-activate)
  (visual-line-mode)
  (smartparens-strict-mode t)
  (gcr/untabify-buffer-hook)
  (fci-mode)
  (hs-minor-mode 1)
  (linum-mode)
  (gcr/turn-on-r-hide-show)
  (aggressive-indent-mode)
  (lambda () (add-hook 'ess-presend-filter-functions
                  (lambda ()
                    (warn
                     "ESS now supports a standard pre-send filter hook. Please update your configuration to use it instead of using advice.")))))

(add-hook 'ess-mode-hook 'gcr/ess-mode-hook)

(defun gcr/turn-on-r-hide-show ()
  "Attribution: SRC https://github.com/mlf176f2/EmacsMate/blob/master/EmacsMate-ess.org"
  (when (string= "S" ess-language)
    (set (make-local-variable 'hs-special-modes-alist) '((ess-mode "{" "}" "#" nil nil)))
    (hs-minor-mode 1)
    (when (fboundp 'foldit-mode)
      (foldit-mode 1))
    (when (fboundp 'fold-dwim-org/minor-mode)
      (fold-dwim-org/minor-mode))))

(defun gcr/Rd-mode-hook ()
  (gcr/ess-mode-hook))

(add-hook 'Rd-mode-hook 'gcr/Rd-mode-hook)

(defun gcr/inferior-ess-mode-hook ()
  (gcr/ess-mode-hook))

(add-hook 'inferior-ess-mode-hook 'gcr/inferior-ess-mode-hook)

(defun gcr/ess-rdired-mode-hook ()
  "Personal customizations."
  (interactive)
  (turn-on-stripe-buffer-mode)
  (stripe-listify-buffer))

(add-hook 'ess-rdired-mode-hook 'gcr/ess-rdired-mode-hook)
#+END_SRC

This [fn:1ffa40c2: http://www.r-bloggers.com/a-small-customization-of-ess/]
post shares a nice setup for the assignment key; primarily if
you use underscores in your variable names, which I do on occasions. After
coding like this for just 10 short minutes it drove me nuts and that is totally
counter intuitive to me; I never would have expected that having to type two
characters to do an assignment would give me nuts. Anyway, the default behavior
is just fine; hit underscore twice gives you an underscore, and one gives you an
assignment!

#+BEGIN_SRC emacs-lisp
(setq ess-S-assign-key (kbd "C-,"))
(ess-toggle-S-assign-key t)
(ess-toggle-underscore nil)
#+END_SRC

*Philosophy*

The current =ESS= maintainers philosophies about how to maintain an ℝ code-base
make sense to me and are virtually the same as my own. Quite simply, the rule is
that the code artifacts are the single source of system definition. Consequently,
the system should be configured in this manner:

We want to keep dump files after loading them; never delete them. The idea
is that if we use them, then they are a valid part of the system definition and
need to be kept.
#+BEGIN_SRC emacs-lisp
(setq ess-keep-dump-files +1)
#+END_SRC

=ESS= allows us to quite easily modify live 𝕊 objects and functions. It provides
this functionality via =ess-dump-object-into-edit-buffer=. These changes are
considered to be experimental, and not part of the master record according to
our philosophy. As such, we don't care to know that these new versions ever
existed and their record will be forgotten from history. In other words, that
new, modified version of the object or function, is never saved to a file for
later reuse.
#+BEGIN_SRC emacs-lisp
(setq ess-delete-dump-files nil)
#+END_SRC

Since our systems are entirely file-based, the entirety of the system most
likely lives in different files. Before loading any file for sourcing, save
any ESS source buffers. This approach is in addition to two other things:
(1) Emacs is auto-saving every file buffer quite frequently and (2) there is
advice before every manual =eval= call so that the buffers and their files stay
in sync. Yes, it is really that important.
#+BEGIN_SRC emacs-lisp
(setq ess-mode-silently-save +1)
#+END_SRC

During the experimental mode of system development, you are likely to hack on
things using an ESS buffer associated with a file. Things can happen quite
unexpectedly, and it is easier to know that the code that you have =eval='d is
the value that is actually currently saved on-disk. You get it by now, that is
my personal preference. It is just a lot easier IMHO to know that your files are
persisted and my be stored in your VCS and that things "look are right".
#+BEGIN_SRC emacs-lisp
(defconst gcr/safb-before-funs-ess
  '(
    ess-eval-buffer
    ess-eval-buffer-and-go
    ess-eval-function
    ess-eval-function-and-go
    ess-eval-line
    ess-eval-line-and-go
    ess-eval-region
    ess-eval-region-and-go
    ess-eval-region-or-function-or-paragraph
    ess-eval-region-or-function-or-paragraph-and-step
    ess-eval-region-or-line-and-step
    ))

(dolist (fn gcr/safb-before-funs-ess)
  (advice-add fn :before #'gcr/save-all-file-buffers))
#+END_SRC

Don't save the workspace when you quit ℝ and don't restore *ANYTHING* when you
start it, either. This adheres to the philosopy that the system is file based.
Period.
#+BEGIN_SRC emacs-lisp
(setq inferior-R-args "--no-save --no-restore")
#+END_SRC

Indent curly brackets correctly:

=smartparens= is serving me well. In this mode it is for curly, round, and square brackets. =ESS= handles indenting mostly right, too. One thing was unpleasant, though. When you define a new function, hitting return brings the curely bracket down to the newline but doesn't give it an empty line and indent the cursor one indentation over so that you may begin implementing the function. That is a big hassle; 4 unnecessary keystroke, it is really distracting and takes you out of the flow. It is such a little thing yet it is so powerfully distracting. It is like a mosquito in your tent! Searching for a solution revealed that I am not alone here.

This post [fn:32fe93bc: http://www.emacswiki.org/emacs/ESSAutoParens] handles brackets,
indentation quite well [fn:5f2adfb8: http://emacs.1067599.n5.nabble.com/indentation-not-working-if-parentheses-are-already-closed-td283806.html] but doesn't provide the behavior that I want.
This post [fn:47104806: https://stackoverflow.com/questions/18420933/enabling-mode-specific-paren-indentation-in-emacs-prelude] captured exactly what I was facing, yet didn't end with a
solution which was kind of shocking. Searching some more I ended up here [fn:cd67477f: https://github.com/Fuco1/smartparens/issues/80], and this seems like the
ideal solution by the author of smartparens himself. This is probably a common thing
 as I found another post
with exactly my situation referencing that aforementioned solution, too [fn:2c7c401d: https://github.com/bbatsov/prelude/issues/374]. This is a nice generalizable
approach that should serve me well for just about everything in this solution-area. Here [fn:5a732a42:: https://github.com/rdallasgray/graphene/blob/master/graphene-smartparens-config.el] is a post
showing a more advanced usage that handles context which is nice to know is an option.

#+BEGIN_SRC emacs-lisp
(sp-local-pair 'ess-mode "{" nil :post-handlers '((gcr/indent-curly-block "RET")))
#+END_SRC

=ESS= executes code in another process. That is no secret. When displaying output
from that code running in another process though, it can look like Emacs is
locking up. That is not the case [fn:2fbb65bd: https://stackoverflow.com/questions/2770523/how-can-i-background-the-r-process-in-ess-emacs].
What is happening that Emacs is waiting for the output. Configure this mode to
continue to accept user input, which is obviously critical, but don't wait for
the process to provide its output. Instead, all output is printed after the last
input lines. What we gain is perceived speed, and what we lose is the nice
sequential this/that/this/that we get from a typical REPL interaction. As I
write this, I'm not totally sure how this will work, but the documentation and
post are consistent and describe what I had wanted here so I will give it a try
and see how it goes.

#+BEGIN_SRC emacs-lisp
(setq ess-eval-visibly 'nowait)
#+END_SRC

Michael explained how to use a richer =eval-expression=, and then showed how to
do the same thing in ℝ. This is the original post, and it will work once I am
on the next version of =emacs= that has the new advice library. Until then, I
won't include this.

#+begin_example
(advice-add
 'debugger-record-expression :around
 (lambda (f exp) (interactive
             (list (read (my-read--expression "Record Eval: "))))
   (funcall f exp))
 '((name . use-my-read--expression)))
#+end_example

# ** Org

# There are 3 ways to install Org [fn:6edaf224: http://orgmode.org/manual/Installation.html]:
# - ELPA
# - Archive
# - Git

# If you are developing Org, then use Git.

# If you are not developing Org, then use ELPA.

# *** Discussion

# Late into the development process I ran into some export to HTML issues.
# After tracking down the source, I learned that tracking down the source of the
# issue in the source itself was out of scope for me. My solution was to break out
# the org-mode configuration into its own block so that I could generate two
# Emacs configuration files. Doing so with a different section was easier, so
# that is how I did it. This turned out to be a configuration change. The
# solution was to disable =pretty-mode= before exporting.

# Tangling can take more than a few minutes; so there is some advice to report on
# it just to me understand what is happening and that it is working. Another way
# to perform this monitoring would have been to use around advice. What I ran
# into is that on HTML export around works fine, but on tangling it did not. This is
# something that I chose not to investigate; instead I reverted the tangling
# advice to two separate commands and that seems to work fine. Since then two
# things have changed:
# 1) There is a new advice system. Not everything is migrated.
# 2) Tangling is kept less than 60s. Most of the long tangle times had to do with
#    mis-configuration of headings and then re-configuring Org to speed it up.

# Org mode, like most of Emacs more powerful modes, slowly grows on you, in
# pleasant and intuitive ways. Pretty soon, you fall in love with it. After
# using it for 50+ hours or so you start wanting some easier way to navigate than
# by typing in the commands over and over (doesn't matter how you re-run them).
# Reading the miscellaneous section, I learned about speed keys [fn:40a1962e: http://orgmode.org/manual/Speed-keys.html#Speed-keys] [fn:d064d3d8: http://notesyoujustmightwanttosave.blogspot.com/2011/12/org-speed-keys.html].
# Wonderful, just wonderful.

# Visualizing hierarchical lists in a flat manner has been fine for me. Sometimes
# though I wanted to depth-based view, but didn't think much more of it. Reading
# about org-mode, I came upon =org-indent-mode= [fn:20c464a3: http://orgmode.org/manual/Clean-view.html#Clean-view], and decided to give
# it a try for a while because it is kind of easier to read. Both modes are
# nice, and thus far I'm switching back and forth as I feel like it. Once I
# opened my eyes and learned about =org-hide-leading-stars= though, I really
# found happiness.

# One topic relating to color themes is that of how code should look within
# a source block in an org file. There was a thread asking about how to
# make the block coloring "better". It was interesting because it revealed my
# preference to myself namely that source blocks should be a muted Gray in
# the document because it shouldn't draw much attention, but in the editor of
# course you get the highlighting that you want. That is my personal
# preference, and =org-src-fontify-natively= is still always an option.
# Over the past six months (now longer) I think, this approach has worked out well.
# Nonetheless I got curious about how things /might/ be with coloring turned on.
# Generally, it looks fine. Strangely though, even with the =solarized= theme it is
# kind of distracting. Beyond sharing that observation, I won't quantify it any
# more than that. The biggest thing for me is that I only want to edit source
# blocks in their "real" mode because:
# - The real mode is present, and therefore
# - All mode specific bindings are present
# - Worth mentioning twice because if I don't have helpers on then I will not
#   match brackets manually!
#   - I've broken code so many times making "quick fixes" and breaking the bracket
#     matching it is exhausting
# - Sending code to REPLs
# - May not sound like much, but those three things are very, very huge in my
#   work-flow

# The good news is that for doing code reviews and stuff, I can always turn on
# that fontification.

# On a somewhat similar thread, =(setq org-src-tab-acts-natively t)= would make it
# easier to edit source blocks outside of the vehicle offered by =org-edit-src-code=.
# Since my intent is never to edit blocks outside for their proper mode though, I
# will not enable that. It is tempting to enable it. Pretty sure that there is an
# on-list discussion where I asked what it would take to dis-allow editing within
# a source block when not in a source buffer. That is an interesting idea. Perhaps
# I should pursue that again. Make it explicit that editing code inside source
# blocks outside of a source block buffer *can never* /work right/. Until I disallow
# editing a source block outside of a source block buffer, this will have to do.

# #+BEGIN_SRC emacs-lisp
# (setq org-src-tab-acts-natively nil)
# #+END_SRC

# This approach of mine, I think I touch upon it elsewhere… at some point I would
# like to refactor this whole document.

# This [fn:d58f4050: http://home.fnal.gov/~neilsen/notebook/orgExamples/org-examples.html]
# article is really fascinating in that crams a ton of information
# into a tiny space. It also is kind of fun to read because it simultaneously
# teaches you so many new things, yet at the same time re-teaches or re-educates
# you about things that you already knew but didn't know that you could or should
# be using in these additional manners.

# The HTML export of org documents has an optional JavaScript supported display [fn:49c014be: http://orgmode.org/manual/JavaScript-support.html].
# Not sure how I ended up on this, but it is actually a very nice option. The
# info style view is nice once you read the directions. The folding interface
# is also interesting; I tried out all 3 generation options but didn't find
# anything that I specifically liked. Perhaps it is a familiarity or comfort
# level with GNU styled docs or the key-bindings.

# Don't use =org= for time-tracking, but if I ever do then [fn:0276223e: https://github.com/koddo/org-clock-statusbar-app]
# this is nice to know of.

# *** Configuration

# For this feature to work, it must come /before/ any =org= load statements
# #+BEGIN_SRC emacs-lisp
# (setq org-list-allow-alphabetical +1)
# #+END_SRC

# **** Org

# =org= chose not to =autoload= everything. The most noticeable
# things in the require statements for =org= are that:
# - Only a few exporters come built, so you need to require them
# - =htmlize= is required for pretty HTML export of code

# #+BEGIN_SRC emacs-lisp
# # (require 'org)
# (require 'ox-beamer)
# (require 'ox-md)
# (require 'htmlize)
# #+END_SRC

# While [[https://github.com/yjwen/org-reveal][org-reveal]] looks pretty nice, the motion sickness it causes is
# unacceptable! Sticking with Beamer for now.

# Exports to Confluence are very helpful.

# #+BEGIN_SRC emacs-lisp
# (require 'ox-confluence)
# #+END_SRC

# =htmlize= should eventually be moved out of this =org= block into its own re-usable
# section. It does need configuring both for =org= and also for general use. I like
# to be able to copy-and-paste its generated HTML into other documents, and =css= is
# the easiest way to achieve it. At some future date, it would be nice to develope
# a proper style sheet to handle any situation. The problem is that right now I don't
# have enough situations to base a design on, just the desire to do so.

# My preference for styling HTML documents has been the same as all printable
# documents: black and white. When you do a =htmlize= export in batch-mode, there is
# no buffer style information to be exported, so you get nice black-and-white code
# formatting. This is an acceptable approach, but I am getting close to setting up
# a style to produce just what I want for HTML export. It is close enough to almost
# require investment to address it. Apparently I wasn't as close as I had thought,
# because there is still no custom stylesheet.

# #+BEGIN_SRC emacs-lisp
# (setq htmlize-output-type 'inline-css)
# (setq org-html-htmlize-output-type htmlize-output-type)
# #+END_SRC

# Building =org= documents is intimately tied to the =org= version, so verify it is
# what we expect.
# #+BEGIN_SRC emacs-lisp
# (defconst gcr/org-version "8.2.10")

# (defun gcr/warn-org-version ()
#   "Warn of org misconfiguration."
#   (interactive)
#   (when (not (version= (org-version) gcr/org-version))
#     (warn "Insufficient org-mode requirements. Expected %S. Found: %S " gcr/org-version (org-version))))
# (gcr/warn-org-version)
# #+END_SRC

# Make sure that exported files are Unicode UTF-8.
# #+BEGIN_SRC emacs-lisp
# (setq org-export-coding-system 'utf-8)
# #+END_SRC

# Do not preserve line-breaks when exporting instead let the destination
# format handle it as it sees fit. This doesn't work like I had expected and makes
# me wonder what I am confused about here. When I export to HTML text containing
# linebreaks no longer has linebreaks. This is what I expect. When I export that
# same text to a buffer though, the line breaks are included. Currently I use
# =sacha/unfill-paragraph= on that code.
# #+BEGIN_SRC emacs-lisp
# (setq org-export-preserve-breaks nil)
# #+END_SRC

# My personal TODO workflow is pretty tame, and it is defined below.

# #+BEGIN_SRC emacs-lisp
# (setq org-todo-keywords
#       '((sequence "TODO" "IN-PROGRESS" "BLOCKED" "REVIEW" "DONE")))
# #+END_SRC

# When running in a GUI, I would like linked images to be displayed inside of
# Emacs.
# #+BEGIN_SRC emacs-lisp
# (setq org-startup-with-inline-images (display-graphic-p))
# #+END_SRC

# When exporting anything, do not insert the exported content into the kill ring.
# #+BEGIN_SRC emacs-lisp
# (setq org-export-copy-to-kill-ring nil)
# #+END_SRC

# Use =ido= completion in =org=.
# #+BEGIN_SRC emacs-lisp
# (setq org-completion-use-ido +1)
# (setq org-outline-path-complete-in-steps nil)
# (setq org-completion-use-iswitchb nil)
# #+END_SRC

# =org= lets you use single letter commands to do stuff on headers. I like to use
# =c= for cycling the header expansion.
# #+BEGIN_SRC emacs-lisp
# (setq org-use-speed-commands +1)
# #+END_SRC

# Ask before execution of shell links. This may look inconsistent given that I allow
# evaluation. It just looks inconsistent.
# #+BEGIN_SRC emacs-lisp
# (setq org-confirm-shell-link-function 'y-or-n-p)
# #+END_SRC

# Ask before execution of emacs-lisp links. This may look inconsistent given that
# I allow evaluation. It just looks inconsistent.
# #+BEGIN_SRC emacs-lisp
# (setq org-confirm-elisp-link-function 'y-or-n-p)
# #+END_SRC

# Make sure that incomplete TODO entries prevent the enclosing parent from every
# turning to DONE.
# #+BEGIN_SRC emacs-lisp
# (setq org-enforce-todo-dependencies +1)
# #+END_SRC

# Allow the mouse to do =org= things like expand and collapse headings.
# #+BEGIN_SRC emacs-lisp
# (gcr/on-gui
#  (require 'org-mouse))
# #+END_SRC

# Use a real ellipsis to render an ellipsis for =org= stuff like showing that a
# header is collapsed.
# #+BEGIN_SRC emacs-lisp
# (setq org-ellipsis "…")
# #+END_SRC

# It is easy to see indentation of headlines without having to count asertisks, so
# don't show them, only show the significant and last one.
# #+BEGIN_SRC emacs-lisp
# (setq org-hide-leading-stars +1)
# #+END_SRC

# Display emphasized text as you would in a WYSIWYG editor.
# #+BEGIN_SRC emacs-lisp
# (setq org-fontify-emphasized-text +1)
# #+END_SRC

# Use Unicode characters to visualize things like right arrow eg \rarr . Most of those
# symbols are correctly exported to the destination format. The most obvious is
# this example in LaTeX versus Text.
# #+BEGIN_SRC emacs-lisp
# (setq org-pretty-entities +1)
# #+END_SRC

# Highlight LaTeX and related markup.
# Normally, I don't do any syntax highlighting, as I believe that should be
# delegated to source buffers, thinking that to do otherwise is distracting.
# However, I already do configure subscripts and Greek letters to be displayed
# with syntax highlighting, because I want to indicate to the human reader that
# they are special, and specifically /not/-Unicode. Do the same thing for LaTeX
# and related markup.
# #+BEGIN_SRC emacs-lisp
# (setq org-highlight-latex-and-related '(latex script entities))
# #+END_SRC

# There is an auto-complete provider for org-mode [fn:a94049d3: https://github.com/aki2o/org-ac]. Nice as I didn't even
# think to check. Perhaps a check should go on the standard setup list. This seems
# to work when you type out things like block definitions; and it won't apply
# to EasyTemplate generated regions. =auto-complete= will still work on them,
# though:
# #+BEGIN_SRC emacs-lisp
# (require 'org-ac)
# (org-ac/config-default)
# #+END_SRC

# Footnote management is an important topic. Thanks to Richard [fn:44cb98d6: https://lists.gnu.org/archive/html/emacs-orgmode/2014-04/msg00172.html], there
# is a concise approach for this, which I've pasted here, along with my original
# question. What I was experiencing was that numbered footnotes became impossible
# to move around. The details, I don't recall as I write this, but I do have more
# about it here.

# #+begin_example
# Context: migrating some contents from one org document into another.
# This is kind of a re-factoring thing where none of it will be reused.

# Goal: Easily copy and paste sections of text along with footnote
# references into the new document, and in doing so, add the contents of the
# previous document to the new document, and let org deal with the new footnote
# names.

# As I write this, I realize that it isn't so simple. I'm just looking
# for a place to start in terms of what is already present and how you deal
# with it currently.
# #+end_example

# #+begin_example
# I use the inline footnote syntax [fn:: ...] for just this reason.  I
# think easy migration of non-inline footnotes would be a nice feature to
# add to Org, though doing it right would be non-trivial.

# A strategy that another user once described to me for dealing with this
# problem is the following:

# 1) Use a regexp search and replace to re-number the footnotes
#    in the region of the text you want to move, giving them high numbers
#    (e.g., prefixing each with "9999").
# 2) Use Org to re-sort the footnotes in the original file, so that the
#    newly-renumbered footnotes all appear at the end.
# 3) Move the text and the footnotes to the new file, which should now be
#    easy, since the footnotes are all grouped together.
# 4) In the new file, use Org to re-number the footnotes back to something
# normal.

# This sounded like a pretty good idea to me, though I haven't had a need
# to try it myself.

# Hope that helps!

# Best,
# Richard
# #+end_example

# As I recall, it is impossible to move footnotes to new documents. I called it
# "refactoring". They were strongly tied to that one document in that one place.
# The following settings "fixed" that.

# #+BEGIN_SRC emacs-lisp
# (setq org-footnote-define-inline +1)
# (setq org-footnote-auto-label 'random)
# (setq org-footnote-auto-adjust nil)
# (setq org-footnote-section nil)
# #+END_SRC

# This is an amazingly easy way to screw up your document. The more you edit
# org docs, the more you realize how you must truly protect it:
# #+BEGIN_SRC emacs-lisp
# (setq org-catch-invisible-edits 'error)
# #+END_SRC

# Though I am not delving deep, it is hard not to want to customize some stuff
# and perhaps this is the start. Even though I enabled this, I don't think that I
# ever used it.
# #+BEGIN_SRC emacs-lisp
# (setq org-loop-over-headlines-in-active-region t)
# #+END_SRC

# By default I never want a table of contents generated. It is so easy to enable
# it with a property, it will be fine to turn it off.
# #+BEGIN_SRC emacs-lisp
# (setq org-export-with-toc nil)
# #+END_SRC

# It is /almost always/ faster to work with org documents when they are fully
# expanded. Anyway, the structure cycling makes it really, really easy to get an
# /outline view/ again.
# #+BEGIN_SRC emacs-lisp
# (setq org-startup-folded "nofold")
# #+END_SRC

# When images are displayed in the buffer, display them in their actual size. As
# the operator, I want to know their true form. Any modifications required for
# export will be stated explicitly.
# #+BEGIN_SRC emacs-lisp
# (setq org-image-actual-width t)
# #+END_SRC

# Hide the delimeter for emphasized text. This may break table alignment. WYSIWYG.
# #+BEGIN_SRC emacs-lisp
# (setq org-hide-emphasis-markers +1)
# #+END_SRC

# Realign tables automatically.
# #+BEGIN_SRC emacs-lisp
# (setq org-startup-align-all-tables +1)
# #+END_SRC

# Sacha implemented a nice feature to export Unicode checkboxes correctly from
# =org=. That will get into the release. Use the workaround and warn when it is no
# longer needed. Now it is in the release. Thanks Sacha and =org= team!

# #+BEGIN_SRC emacs-lisp
# (setq org-html-checkbox-type 'unicode)
# #+END_SRC

# Before exporting to PDF, save all buffers to make sure that everything is a
# known good state.
# #+BEGIN_SRC emacs-lisp
# (defadvice org-latex-export-to-pdf (before before-org-latex-export-to-pdf activate)
#   (gcr/save-all-file-buffers))
# #+END_SRC

# =org-show= need special handling, see the install for details.
# #+BEGIN_SRC emacs-lisp
# (let ((pkg 'org-show))
#   (gcr/on-gui
#    (if (not (el-get-package-is-installed pkg))
#        (warn "You wanted %S to be installed, but it isnt. Fix this." pkg)
#      (let ((fil (concat (el-get-package-directory pkg) "org-show.el")))
#        (if (not (f-exists? fil))
#            (warn "You wanted %S to exist, but it doesn't. Fix this." fil)
#          (load fil)))))
#   (gcr/not-on-gui (warn "You wanted %S to be loaded, but it won't be… it doesn't work without a GUI for some reason." pkg)))
# #+END_SRC

# **** Babel

# There is a hook for things to do after a source block has been executed. This
# tip appeared in this [fn:edec422c: https://lists.gnu.org/archive/html/emacs-orgmode/2014-07/msg00309.html]
# discussion and Nick Dokos agreed here
# that [fn:32dff2df: http://article.gmane.org/gmane.emacs.orgmode/88741]
# that it is the ideal approach because it does not interfere with export.

# This thread [fn:5863d9db: https://lists.gnu.org/archive/html/emacs-orgmode/2015-01/msg00534.html] explained
# the correct approach as of <2015-01-22 Thu>, which meant a simpler function call.

# #+BEGIN_SRC emacs-lisp
# (defun gcr/org-babel-after-execute-hook ()
#   "Personal settings for the `org-babel-after-execute-hook'."
#   (interactive)
#   (org-redisplay-inline-images))

# (add-hook 'org-babel-after-execute-hook 'gcr/org-babel-after-execute-hook)
# #+END_SRC

# Load the =ob-sml= package. Perhaps some day it will end up in the mainline.

# #+BEGIN_SRC emacs-lisp
# (require 'ob-sml nil 'noerror)
# #+END_SRC

# Tell =org= that it may evaluate all of the listed languages.
# #+BEGIN_SRC emacs-lisp
# (org-babel-do-load-languages
#  'org-babel-load-languages
#  '((calc . t)
#    (css . t)
#    (dot . t)
#    (ditaa . t)
#    (emacs-lisp . t)
#    (js . t)
#    (latex . t)
#    (lilypond . t)
#    (makefile . t)
#    (org . t)
#    (perl . t)
#    (python . t)
#    (plantuml . t)
#    (R . t)
#    (scheme . t)
#    (sh . t)
#    (sml . t)
#    (sql . t)))
# #+END_SRC

# There is a way to disable property inheritance that speeds up tangling a lot.
# The problem is that you lose property inheritance which is unacceptable. Never,
# never allow that.
# #+BEGIN_SRC emacs-lisp
# (setq org-babel-use-quick-and-dirty-noweb-expansion nil)
# #+END_SRC

# You may display syntax highlighting for code in source blocks. I don't.
# #+BEGIN_SRC emacs-lisp
# (setq org-src-fontify-natively nil)
# #+END_SRC

# On export, maintain the literal spacing as found in the source block. Obviously
# this is important for makefiles. It is really important everywhere because
# anything else would violate the law of least surprise.
# #+BEGIN_SRC emacs-lisp
# (setq org-src-preserve-indentation +1)
# #+END_SRC

# When source blocks are exported, do not indent them arbitrarily. This does
# nothing given that the previous setting is non-null; however I believe that I
# set this for a reason that I may no longer recall.
# #+BEGIN_SRC emacs-lisp
# (setq org-edit-src-content-indentation 0)
# #+END_SRC

# When edit mode is exited, the option exists to automatically remove empty
# opening and closed lines for the source block. Never do this. The thing is that
# I forgot why. When I was working on a recent analysis with ℝ there was a
# space appearing in the opening and closing line of the source block that didn't
# appear in the source editing buffer. That surprised me. I am sure that I've
# forgotten why this is the case. I don't like it because you add a bunch of
# empty lines in the source buffer for every source block. With that in mind I
# will enable this feature and try it out again.
# #+BEGIN_SRC emacs-lisp
# (setq org-src-strip-leading-and-trailing-blank-lines t)
# #+END_SRC

# For code blocks that I use a *lot*, add templates for source blocks because my
# current approach is to do a =<s= \rarr =TAB= \rarr  =ema= \rarr =auto-complete= and you know
# that is kind of wasting time. I will check out the statistics to see much I use
# this to back up my claim at some point. Thanks John Kitchin for reminding me
# not to be stupid [fn:028fcfca: http://kitchingroup.cheme.cmu.edu/blog/2014/01/26/Language-specific-default-headers-for-code-blocks-in-org-mode/]. It makes sense to add helpers for every language that
# I use. Be sure to do so when I use them a lot.

# #+BEGIN_SRC emacs-lisp
# (add-to-list
#  'org-structure-template-alist
#  '("el" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC" "<src lang=\"emacs-lisp\">\n?\n</src>"))
# #+END_SRC

# # OOTB the templates are all upper case. Case shouldn't matter inside of =org=,
# # but on my system it breaks =org=. This needs to be investigated, and until then
# # I will just downcase all of the templates.

# # #+BEGIN_SRC emacs-lisp
# # (mapc (lambda (asc)
# #         (let ((org-sce-dc (downcase (nth 1 asc))))
# #           (setf (nth 1 asc) org-sce-dc)))
# #       org-structure-template-alist)
# # #+END_SRC

# It looks like ℝ is going to be another one, but don't process it to downcase it…
# order matters here. There are more now. At some point these should be
# refactored.
# #+BEGIN_SRC emacs-lisp
# (add-to-list
#  'org-structure-template-alist
#  '("r" "#+BEGIN_SRC R\n?\n#+END_SRC" "<src lang=\"R\"></src>"))
# (add-to-list
#  'org-structure-template-alist
#  '("p" "#+BEGIN_SRC plantuml\n?\n#+END_SRC" "<src lang=\"plantuml\"></src>"))
# (add-to-list
#  'org-structure-template-alist
#  '("sh" "#+BEGIN_SRC sh\n?\n#+END_SRC" "<src lang=\"sh\"></src>"))
# (add-to-list
#  'org-structure-template-alist
#  '("d" "#+BEGIN_SRC ditaa\n?\n#+END_SRC" "<src lang=\"ditaa\"></src>"))
# #+END_SRC

# Sometimes tangling and exporting takes a long time and I would like to see some
# status messages. Shell commands can report duration, too.

# #+BEGIN_SRC emacs-lisp
# (defun gcr/org-babel-tangle (orig-fun &rest args)
#   "Display tangling time."
#   (gcr/save-all-file-buffers)
#   (let ((start (current-time)))
#     (message (concat "org-babel-tangle BEFORE: <"
#                      (format-time-string "%Y-%m-%dT%T%z")
#                      ">"))
#     (apply orig-fun args)
#     (let* ((dur (float-time (time-since start)))
#            (msg (format "Tangling complete after: %.06f seconds" dur)))
#       (message (concat "org-babel-tangle AFTER: <"
#                        (format-time-string "%Y-%m-%dT%T%z")
#                        ">"))
#       (message msg)
#       (gcr/on-gui (alert msg :title "org-mode")))))

# (advice-add 'org-babel-tangle :around #'gcr/org-babel-tangle)

# (advice-add 'org-ascii-export-as-ascii :before #'gcr/save-all-file-buffers)

# (defadvice org-html-export-to-html (before before-org-html-export-to-html activate)
#   (gcr/save-all-file-buffers)
#   (message (concat "org-html-export-to-html BEFORE: <"
#                    (format-time-string "%Y-%m-%dT%T%z")
#                    ">")))

# (defadvice org-html-export-to-html (after after-org-html-export-to-html activate)
#   (message (concat "org-html-export-to-html AFTER: <"
#                    (format-time-string "%Y-%m-%dT%T%z")
#                    ">")))
# #+END_SRC

# When source blocks are evaluated, their results get stored in a result area,
# typically for display. If the results are small, they are displayed with colons
# instead of an =example= block. My preference is to *always* place them in an
# example block. This makes exports more consistent and other =org= features seem
# to behave more predictably.

# #+BEGIN_SRC emacs-lisp
# (setq org-babel-min-lines-for-block-output 0)
# #+END_SRC

# ALEC's value system for managing file-state and enabling-flow is documented up
# in [[Buffers][buffers]]. It cares about file-backed buffers. Org source block buffers are
# are kind of different. They are not backed by a file. They are backed by their
# base buffer; the one on which the source block exists. The base buffer is backed
# by a file. ALEC is configured to "do the right" thing in regards to maintaining
# the state of that file. How will ALEC handle operating in the source block
# editing buffer, though? I don't now yet but I will tell a story here.

# Assumption: all of the goals defined up in [[Buffers][buffers]] will be configured and in
# effect while editing a source block so flow will be maintained. If that is true,
# then everything will work the same. I tried it out. Everything seems to work
# as expected from up above. With that in mind, I think that we can rely upon that
# configuration to do the right thing for org source block buffers in regards to
# realizing the goals. Therefore, idle-delay doesn't need to be configured here
# again.

# #+BEGIN_SRC emacs-lisp
# (setq org-edit-src-auto-save-idle-delay 0)
# #+END_SRC

# Never save the source buffer to a different file, either. This setting makes
# =org= act correctly for the goals in [[Buffers][buffers]] by relying on the configuration in
# that heading instead of adding another configuration unique to =org=. Both are
# explicitly disabled here with this goal in mind.

# #+BEGIN_SRC emacs-lisp
# (setq org-edit-src-turn-on-auto-save nil)
# #+END_SRC

# The source block buffer may be configured to appear in a few different places.
# For a while I really liked =reorganize-frame= because sometimes you want to be
# able to see the code you are editing in edition to the rest of the document. At
# least that is what I am telling myself. Once I learned you could change it I
# realized that 1 I should have asked if it could be changed and 2 I should have
# changed it. The flow that I've got configured here is that you are either in the
# source document where code blocks are not highlighted or you are in the source
# block so you are editing in a buffer that is full-fledged ALEC. That is the best
# way so you can focus completely on each task at hand in the ideal mode for that
# task. Anything else results in distractions and errors.

# #+BEGIN_SRC emacs-lisp
# (setq org-src-window-setup 'current-window)
# #+END_SRC

# When you evaluate code its results are inserted into a =RESULTS= block by
# default. The documentation indicates though that you may instead use a name
# if the source block has a name, or a cache-id. In either case, both seem to be
# better options for traceibility.

# #+BEGIN_SRC emacs-lisp
# (setq org-babel-results-keyword "NAME")
# #+END_SRC

# =org= has a really nice feature that hitting =C-c C-c= will generally just do
# the /right thing/. It is really nice. That feature extends to source blocks of
# course. Ironically I had a typo here, typing /of curse/ instead of /of course/.
# The thing is that you really, really need to develop a personal workflow, and
# then configure the tool to enable it. The more I learn about =org=, the more
# leery I am about making it really easy to evaluate code. I want it to be a
# really, really specific and decided action to evaluate a code block, so don't
# make it so easy as =C-c C-c=.

# #+BEGIN_SRC emacs-lisp
# (setq org-babel-no-eval-on-ctrl-c-ctrl-c +1)
# #+END_SRC

# =org= already uses the guillemet [fn:086b7602: https://en.wikipedia.org/wiki/Guillemets]
# for demarcating noweb references, but it does it using the work-around of just
# using less-than and greather-than characters twice. That is fine. Because Emacs
# supports Unicode just fine though, tell =org= to use the real symbol.

# #+BEGIN_SRC emacs-lisp
# (setq org-babel-noweb-wrap-start "«")
# (setq org-babel-noweb-wrap-end "»")
# #+END_SRC

# My preference is to rely upon heading property inheritance to define source block
# names. That way, you can just do your work knowing "where" you are working and
# keep it simple by not having to name everything. That was just fine until I
# wrote a document where I needed to name each source block.

# It gets easy to forget the source block’s name. Not the end of the world, but very nice to know. After enabling FlyCheck, it started complaining pretty quickly in
# source blocks. The attributed poster explained a fix. Previously I added the
# fix with advice to my own function, which was a mistake.

# #+BEGIN_SRC emacs-lisp
# (defun gcr/org-edit-src-code-plus-name ()
#   "Edit the well-described source code block.

# Attribution: URL `https://lists.gnu.org/archive/html/emacs-orgmode/2014-09/msg00778.html'

# Attribtion: URL `http://emacs.stackexchange.com/a/8168/341'"
#   (interactive)
#   (let* ((eop  (org-element-at-point))
#          (name (or (org-element-property :name (org-element-context eop))
#                   "ॐ"))
#          (lang (org-element-property :language eop))
#          (buff-name (concat "*Org Src " name "[" lang "]*"))
#          (file-name (buffer-file-name)))
#     (org-edit-src-code nil nil buff-name)
#     (setq buffer-file-name file-name)))
# #+END_SRC

# It would be nice to be able to use =vc-next-actionl= when editing source blocks in
# the source block edit buffer. Those buffers are new buffers that get the
# contents of the source block copied into them, the mode gets loaded, and
# additional hooks for this special org mode source editing are run. When editing
# is complete, the contents of that buffer are copied back into the source block,
# the original contents are removed, and the new ones are inserted. I wasn't sure
# how to proceed with this and asked the list. Aaron Ecay explained how to simply
# close the buffer first. That is a nice approach because everything will be as
# close to normal operational procedures as possible. Jonathan Leech-Pepin showed
# how to get a handle on the source buffer, and execute some code in the context
# of /that/ buffer. In this case it would mean executing the commit action inside of
# the backing buffer. Both are great options, and I am having trouble with both of
# them. The former is great because it is exactly how you would do it now. The
# latter is great because you would *not* be interrupted with the source block
# buffer being closed. At this point, I've only got the former working so that is
# where I will start. After some time and continuing to refine this configuration
# of ALEC, I got the idea that this was no longer necessary. I thought
# that vc-next-action does what you would expect and you don't need to drop back
# to the backing buffer. I thought that this is probably the case because of both
# the =org= configuration in ALEC and aggressively saving buffers. I made the change
# and everything seems to work fine until the following happens:

# What happens when only a save before =vc-next-action= is that everything seems to
# work fine, but then after the commit, ALEC returns to the source buffer, which
# is fine, but when I go to the backing buffers, the entire contents of the
# backing buffer are placed back into the source block containing that very
# buffer! That is why I have this code to leave the source block before committing!

# Clearly, I tweaked something wrong here, or there is a simple fix, and I'm not
# going to investigate right now. This refactor also reflects reading the manual
# on advice. This is a case where it doesn't make sense to use advice to do
# something different for one special case. =gcr/vc-next-action= is logic
# unique to one one so it should be a function, not advice. The advice for
# =vc-next-action= will handle the obvious. This function might belong in another
# section. =vc-next-action= used to be advised to do a save, but the advice seemed
# to screw up the call here. That /is/ consistent with the recommendation in the
# user manual not to combine/complicate advice and functions when you can do all
# of the work directly in the function because you defined it.

# #+BEGIN_SRC emacs-lisp
# (defun gcr/vc-next-action ()
#   "If in org source block, exit it before `vc-next-action'."
#   (interactive)
#   (when (condition-case nil
#             (org-src-in-org-buffer)
#           (error nil))
#     (org-edit-src-exit))
#   (gcr/save-all-file-buffers)
#   (vc-next-action nil))
# #+END_SRC

# Thank you Nicolas Goaziou [fn:486109d1: https://lists.gnu.org/archive/html/emacs-orgmode/2014-11/msg00776.html],
# for the beginnings of an =org-lint=. The goal here was to:
# 1) Report an error if there is a source block without a language
#    specified
# 2) Report an error if there is a source block with a language specified
#    that is *not* present in `org-babel-load-languages'
# And, it does. My build has been broken *many* times because of the lack of a
# language type for a source block. There is never a warning and it is very
# confusing.
# #+BEGIN_SRC emacs-lisp
# (defun gcr/src-block-check ()
#   (interactive)
#   (org-element-map (org-element-parse-buffer 'element) 'src-block
#     (lambda (src-block)
#       (let ((language (org-element-property :language src-block)))
#         (cond ((null language)
#                (error "Missing language at position %d"
#                       (org-element-property :post-affiliated src-block)))
#               ((not (assoc-string language org-babel-load-languages))
#                (error "Unknown language at position %d"
#                       (org-element-property :post-affiliated src-block)))))))
#   (message "Source blocks checked in %s." (buffer-name (buffer-base-buffer))))
# #+END_SRC

# Use =gcr/org-edit-src-code-plus-name=. It uses =org-edit-src-code= and replaces it
# in use here.

# #+BEGIN_SRC emacs-lisp
# (setq org-edit-src-code nil)
# #+END_SRC

# ***** Core Babel Configuration

# There is a performance issue with tangling when header property inheritance is
# enabled. Eric explained that [fn:419e4704: https://lists.gnu.org/archive/html/emacs-orgmode/2014-06/msg00719.html] there may be performance gains if some
# of the header properties are not considered. The list below defines what will
# be allowed, and everything else will be removed. With only six properties you
# sure can do a *lot*.
# #+BEGIN_SRC emacs-lisp
# (let* ((allowed '(exports
#                   file
#                   noweb
#                   noweb-ref
#                   session
#                   tangle))
#        (new-ls
#         (--filter (member (car it) allowed)
#                   org-babel-common-header-args-w-values)))
#   (setq org-babel-common-header-args-w-values new-ls))
# #+END_SRC

# ****** Comments [fn:1e1a7e1f: http://orgmode.org/manual/comments.html#comments]

# There is always a question of how to instill traceability in your artifacts. =org=
# provides =:comments= for that. Tangling with that value set to =link=,
# for example, would add a prefix and postfix comment to the tangled file with the
# name of the header from which the generated file was tangled. When I tangle the
# .emacs.el, then it puts something like this for that:
# #+begin_quote
# ~;; [[file:~/git/bitbucket-grettke/home/TC3F.org::*Fully%20Loaded%20System][Fully\ Loaded\ System:1]]~

# file contents go here

# ;; Fully\ Loaded\ System:1 ends here
# #+end_quote
# When you follow the link, it will take you right back to the block that
# specified the tangling of the document. That is a start, though not super for
# tracking down details of where the code snippets really originated down to the
# source blocks themselves.

# Speaking of tracibility, this post [fn:16e26884: http://comments.gmane.org/gmane.emacs.orgmode/32814]
# explains another approach:

# #+begin_example
# I've just added functions for detangling code from pure source code
# files back into code blocks in the org-mode files from whence they were
# tangled.  This is done by the new `org-babel-detangle' function.
# Additionally the new `org-babel-tangle-jump-to-org' function can be used
# to navigate from a pure source code file back to the related code block
# in the original Org-mode file.

# Both of these new functions require that the code block was tangled with
# comments which can be accomplished by setting the :comments header to
# "yes".

# This should be useful for collaborating with anyone who would rather
# edit source-code files directly rather than keeping the canonical
# versions of all source-code in Org-mode files.  You'll just have to
# convince your collaborators to leave the link comments in the source
# code file.
# #+end_example

# Trying to understand the other settings, I found =both= to look like this:
# #+begin_quote
# ;; Fully Loaded System
# ;; Convert decisions into a runnable system.

# ~;; [[file:~/git/bitbucket-grettke/home/TC3F.org::*Fully%20Loaded%20System][Fully\ Loaded\ System:1]]~

# file contents go here

# ;; Fully\ Loaded\ System:1 ends here
# #+end_quote

# =noweb= looks like, well I'm going to put a couple examples, because this
# is the best setting. This provides was 99% of org mode literate programmers
# want which is traceability back from every tangled piece of code to the original
# document.
# #+begin_quote
# ;; [[file:~/git/bitbucket-grettke/home/TC3F.org::*Windows%20%5Bfn:38%5D][nil]]
# ;; [[file:~/git/bitbucket-grettke/home/TC3F.org::*Windows%20%5Bfn:38%5D][nil]]
# ;; [[file:~/git/bitbucket-grettke/home/TC3F.org::*Frames%20%5Bfn:46%5D][nil]]
# #+end_quote
# After all of this research, I found that doing noweb-ref tangling, the source
# locations are not included, so it is no very useful to include comments, and
# I removed them, at least for now. I am not sure how I want to use them right
# now.

# The type of information that you provide as meta-data is up to you and depends
# upon your mental model for your org document. My mental model is mostly to use
# headings as the logical area for addressing a particular /concern/ satisfied by
# that portion of my Emacs configuration, so the tangling comments reflect that.
# In other words, in this document at least, I rarely name source blocks because
# the header name is the "true name", and closing the tangle comment with the
# source block name is really confusing because it usually is =nil=. The org
# links are fine, too, because they convey all of the necessary information
# whether you are using org or not. It is more likely that most readers will not
# use org links, so they come second.

# As it happens, that didn't really work out as I had hoped. The =link= style
# works, and =noweb= does not. Not sure why and not digging further, so sticking
# with that. Also, I had customized the links, and did that incorrectly, so I
# removed those, too. When Eric said that one part of it wasn't implemented, I
# didn't to dig into what was working anymore than I had already because it has
# already been many hours invested.

# Now I've got weeks invested and I'm shocked to find that using links in the
# tangled file is worse then useless, it is actually harmful. It just doesn't
# help, atleast in the sytems that I am tangling. As such I am no longer using
# it.

# Well, just read a post of another person using it (many months after I retired
# it), and I think that I want to try keeping it around. My problem was probably
# between my keyboard and chair so I will give it another go.
#+BEGIN_SRC emacs-lisp
(gcr/set-org-babel-default-header-args :comments "noweb")
#+END_SRC

# ****** Results [fn:1625d11f: http://orgmode.org/manual/results.html#results]

# Always display results like you would seem them in a REPL, replacing theme each
# time you evaluate the block.
# #+BEGIN_SRC emacs-lisp
# (gcr/set-org-babel-default-header-args :results "output replace")
# #+END_SRC

# ****** Exports [fn:7dad95aa: http://orgmode.org/manual/exports.html#exports]

# Include both code blocks and results in exports. This is not saying that the
# blocks will be evaluated on export; this is only saying that these two things,
# their representation, will be included in the export.
# #+BEGIN_SRC emacs-lisp
# (gcr/set-org-babel-default-header-args :exports "both")
# #+END_SRC

# ****** Noweb [fn:3da67e2d: http://orgmode.org/manual/noweb.html#noweb]

# Expand noweb references before the block is tangled or evaluated, but no
# exported. This embraces the notion that you are telling the right thing to the
# computer and the right thing to the human. This is the only proper setting to
# do so. Code is code for the "computer". Code is symbolic for the human reader.

# #+BEGIN_SRC emacs-lisp
# (gcr/set-org-babel-default-header-args :noweb "no-export")
# #+END_SRC

# ****** Padline [fn:508104fc: http://orgmode.org/manual/padline.html]

# # Deals with inserted code blocks and whether or not you have padding around
# # them. For a while I liked that, to make it easier to see. Then I used comments
# # to make it clear, but I may or may not use them. Finally, I decided that not to
# # make it easier for that form of the code to read for humans, because that is
# # what the LP document is for.

# # After doing that, which totally made sense, I decided to give tangle comments a
# # go again, and although we are still generating for a computer, it can be nice
# # when =de-tangling= to have some space.

# # Reading the documentation, I see that this setting is required for
# # =org-babel-tangle-jump-to-org= to work.

# # #+BEGIN_SRC emacs-lisp
# # (gcr/set-org-babel-default-header-args :padline "yes")
# # #+END_SRC

# # This /may/ interact with a setting I've got above to remove empty prefix and
# # postfix lines in source blocks.

# ****** Eval [fn:f6ab36a6: http://orgmode.org/manual/eval.html#eval]

# This is probably the single most important configuration parameter for your
# document's source blocks. Initially, that value is obscured by the need to
# configure the rich variety of other options though, and this parameter is often
# visited during the second eighty percent of your investment in =org-babel= when
# you are "in the thick" of it.

# Still trying to make sense of it all myself, I am adhering to a lightweight
# user-story driven configuration of this feature, as I believe that it is the
# only way that it will make sense to me. The key goal here for me is to:

# - Define typical usage scenarios
# - Identify key traits
# - Realize those traits in my workflow

# The current configuration is more like:
# - Default allows for super fast code execution, storing the results
# - Any form of reproducible research

# ******* Story A: Messages

# 20% of my time spent composing email or mailing list messages. Those messages
# may be composed of plain text with some nice markup. They also might have
# references and citations. The big value comes with superb code block definition
# and execution facilities. Those messages are short-lived; they are never stored
# in =git= and unlikely to even end up on the file-system.

# My work-flow here is:
# - Compose the =org= document
# - Prepare necessary buffers for code evaluation
# - Execute (weave) source blocks and store the results within the document
# - Export to the destination format

# ******* Story B: Notes

# 40% of my time is spent taking notes. It is so delightful to do so here. A lot
# of those notes are for programming languages so the workflow is nearly identical
# to =A=. The actions for navigating among source blocks is used all
# of the time to quickly navigate the document's source code, reflecting more
# thoughtfulness while working with the document. There is more concern here,
# because the document is stored in =git= and long-lived, it will be published
# many times. An important approach here is that I like to make a clear and
# concise distinction of the responsibilities of tangling and exporting because I
# don't like surprises. I want to know how source blocks results were generated,
# and when, as well as details about the export itself. This is a scope
# restriction that opens up space to make better sense of the workflow of the
# document itself. At its simplest, I just want to see a date-time showing when
# the document was published for example.

# My workflow here is:
# - Compose the =org= document
# - Prepare necessary buffers for code evaluation
# - Execute (weave) source blocks and store the results within the document
# - Export to the destination format
#   - Evaluate in-line source code relevant to that particular exportation
#   - These two distinct phases demonstrate when the document is modified
#     - At execute time: results are stored for every non-inline source block
#     - At export time: results are included in the exported document for every
#       inline source block

# ******* Story C: Documents

# 40% of my time is spent managing documents. In my case, it is this document.
# There are others, but they are minute in comparison. This is the storehouse,
# proving ground, and production deployment environment for every thought, idea,
# dream, and goal that I can come up with in regards to ALEC. It shares the same
# traits as =A= and =B=, and adds many more.

# The first addition is the utilization of =no-web= to tangle source code and also
# tangle executable source code. The document evolution has relied heavily upon
# this feature. It has allow amazing flexibility. It is so critical that it must
# always be available.

# The second addition is a different scope of concern. My desire to make the
# tangling and exportation of this document more controlled. Unsure,
# I waver between restricting evaluation of code blocks by default and enabling
# over the entire document and simply allowing it globally. I don't like
# accidentally evaluating source blocks and getting their results, but I suppose
# that I may rely upon my commits to reveal my error. I suppose that my big
# takeaway here is that I want it simple, and want to be able to lock things down
# if necessary.

# ******* Study

# Studying the scenarios, the desires seem clear. There is a combination of
# agility and scope that ought to make productivity go up. The essence may be
# better expressed in terms of responsibilities based upon my preferences
# expressed above:

# - A document is responsible for
#   - Defining source blocks
#   - Configuring their execution environments
#   - Displaying their results
# - Execution of this document is responsible for
#   - Evaluating source blocks
#   - Collecting results of evaluation
# - Tangling is responsible for combining source blocks
#   - In this file
#     - For output blocks
#     - For inclusion in source definitions used in function calls
#   - In a new file
# - Exporting is responsible for
#   - Converting this document to a new presentation format
#   - Only in-line source blocks may be evaluated during exporatation
#     - Be explicit about the difference eg
#       - Execution results as stored in the document
#       - Exportation results are stored in the export document
#       - Key difference for people to make sense of things

# ******* Preface to Tooling

# The next task is to convert the studies desired into a configuration to realize
# them. At first blush the configuration options will seem confusing. The best
# approach is to "play" with the configurations to learn and finalize your
# approach. That is how I ended up with this configuration. All of the
# configuration it based upon that combination of need and desire and how the
# system itself works. At best, it will only make sense in this context. Over
# time, it will make more sense. That period of evolution and growth is reflected
# in the =org= documentation itself for example when you read about =ditaa= in regards
# to exporting [fn:14fb5203: http://orgmode.org/manual/Exporting-code-blocks.html].
# The more familiar and comfortable with =org= one becomes, the more sense mentions
# such as that make.

# ******* A More Concise Goal (Making Sense of Things)

# This facilitate my personal model for =LP= with =org= for evaluation modes. There
# are only two of them, =A= and =B=.

# Mode =A= allow execution to occur where the results are likely to be captured
# within the document. The single responsibility of that mode is to perform and
# capture the entirety of the computation. That really sums it up. All computation
# is done here because it is time and context sensitive. The document in that form
# will serve as a snapshot in time. If you run ℝ code then capture the results and
# plots and also the version of itself and the packages used. If you have
# versioned links for your data set, then report it here. Think of future users
# of your research as archeologists trying to piece together what you did; you
# should make their job really easy. This is a self contained computational unit,
# and its results, too. Include everything that matters for your computation.
# Consider Vagrant [fn:28698f18: http://www.vagrantup.com/] regardless of how much
# slower it may run on a virtual. How you defined this document and computed it
# and captured and the results are all *one* thing that needs to both be considered
# and captured in its entirety.

# Mode =B= is a little simpler. All of the hard work has been done. Everything just
# mentioned has been done. This is purely responsible for publishing. Perhaps you
# want to submit it to a journal, that is publishing. Perhaps you want to post it
# on a blog, that is publishing. Publishing has different concerns. You want to
# know about the environment used to perform the publishing, like the tools and
# the time. Perhaps you want to more about the computer is was published on. All
# of those aspects unique to that event of publishing should be included during
# export. The operator really needs to get on-board with the idea of
# /computational artifacts/ vs /publishing artifacts/.
# For example if you execute mode =A= then you need to store all of its generated artifacts. That includes data, but also
# graphics that you reference in the document itself. Hopefully you are
# questioning my claim here. You should! You area asking "Why should I when I
# can reproduce the results?!". Great question. The answer only makes sense
# according to the philosophy I am embracing. Mode =A= defines both the computational
# unit and its constituent output. That is a single /thing/, a single /thing document/.
# Now that I am writing this, I am having questions about my claim here, and I will
# explore them as my understanding is bettered. For now, I am sticking with this
# because for example I know that I can use PNG anywhere. Well, questions arise
# because I am unsure how I would publishing to the web without re-generating SVG
# output vs PNG for web vs PS for LaTeX. Definitely something I will need to
# explore and for now I am sticking with the plan. Just had lunch and reflected
# upon the fact that there is clearly a distinction between the results of your
# computation and how you wish to publish them, and when. My feeling is that my
# approach is acceptable in that the computation and generation of summary
# results is definitely a separate goal from providing it in a particular
# publishing format and surely more experience needs to be accumulated here.

# Perhaps the simplest thing to do for greater flexibility is to:
# - In =A=
#   - Perform the computation
#   - Capture the results of the computation
#   - Produces images and so forth
# - In =B=
#   - Publish, convert, to a new format

# The key questions are:
# - May you?
#   - Yes you may
# - Should you?
#   - Perhaps
#   - It seems easier to separate concerns into computation and publishing/presentation

# That is why evaluation is available on export, to capture aspects unique of
# export itself, and *not* of the computation. To realize this, the operator must be
# very thoughtful and aware of the execution model of the document. As it stands,
# you may separate the time of execution of code blocks and also their results.
# This is a subtle yet hugely important idea. You may utilize this feature and
# idea anyway you please, but I will use it a certain way. All computational
# evaluation and results storage will occur for source blocks in =A=. That is the
# goal. However, we do not want that to occur for in-line source blocks in mode =A=.
# That is possible and doable, but we do not want it because it would not stay
# true to the original goal. Maintaining separation clearly, that normal source is
# evaluated at execution time and inline-source is evaluated at publishing time
# will make things crystal clear. This will make it easy for the operator of the
# document to *see* the difference between results for =A= versus =B= because the latter
# will never have its results stored within the source document.

# A strict separation between the =A= and =B=, roughly computation and publish, must
# be maintained. It is the only way to make sense of how to use =org= as a tool here.
# One mode is responsible for computation, and the other is responsible for
# publishing. All of the following configuration is performed in order to realize
# this goal of A:computation vs B:publishing.

# ******* Putting the Pieces Together

# Make it crystal clear that if the operator wants to evaluate source blocks then
# she may do so. It is a fundamental right of every =org= mode user and the default
# configuration shall allow it. If she wants restrictions, then they may easily be
# added to the document itself.

# #+BEGIN_SRC emacs-lisp
# # (setq org-confirm-babel-evaluate nil)
# (gcr/set-org-babel-default-header-args :eval "always")
# #+END_SRC

# Separate evaluation into two distinct phases or modes that of =A= for computation
# and =B= for presentation/publishing/exportation (still unsure of the best name
# given the existing terms both inside and outside of =org=).

# During exportation, only evaluate inline source blocks.

# #+BEGIN_SRC emacs-lisp
# (setq org-export-babel-evaluate 'inline-only)
# #+END_SRC

# During exportation, evaluate the blocks and replace the source blocks with the
# resulting value. This gives you exactly what you would expect; the documents
# look like plain old documents because they are exactly that.

# #+BEGIN_SRC emacs-lisp
# (gcr/set-org-babel-default-inline-header-args :eval "always")
# (gcr/set-org-babel-default-inline-header-args :results "value replace")
# #+END_SRC

****** ℝ Specific

Always use the current ℝ session for evaluation.
#+BEGIN_SRC emacs-lisp
(gcr/set-org-babel-default-header-args:R :session "*R*")
#+END_SRC

# **** KOMA-Script

# I enjoy writing letters. I enjoy reading letters. LaTeX produces letters that
# are easy to print and read. Org provides a [[http://orgmode.org/worg/exporters/koma-letter-export.html][KOMA Script exporter]] for [[https://www.ctan.org/pkg/koma-script?lang%3Den][koma-script]].
# The Org documentation mentions that the user should read the [[http://orgmode.org/cgit.cgi/org-mode.git/plain/contrib/lisp/ox-koma-letter.el][ox-koma-letter.el]]
# header documentation.

# The [[https://www.ctan.org/pkg/babel?lang%3Den][babel]] packages is mentioned in the Org documentation. The package
# documentation explains that it should be used with LaTeX, but not XeTeX. Some
# time ago I decided to stick with LaTeX.

# Load the KOMA exporter.

# #+BEGIN_SRC emacs-lisp
# (eval-after-load 'ox '(require 'ox-koma-letter))
# #+END_SRC

# - Understanding KOMA and how to use it
#   - There are 4 ways to set letter metadata, listed "from the most specific to
#     the most general" (not sure exactly what this statement means, and the conclusion of my notes tries to make sense of what is really going on here and what is the best way to do things)
#     - Org option lines (ORG)
#     - Separate Org latex classes (LTX)
#     - Emacs Lisp variables (LISP)
#     - Letter Class Option files (LCO)
# - Notes and thoughts on the ways to use it
#   - LTX
#     - By following the setup directions, you do this, creating "my-letter" class
#     - Familiar and easy if you already know LaTeX
#       - At some point in your workflow, you *must* define a class to use, anyway
#     - Very easy to do, just define the class template and set =org-koma-letter-default-class=
#   - ORG
#     - Simple way that makes it very easy to just focus on the document content
#     - This metadata takes highest priority in the workflow
#       - So you should set your typical defaults in LISP or LCO and customize it
#         here. This is exactly what I wanted to know.
#       - This lets you do your tweaking in each unique file while relying on the
#         most common defaults defined elsewhere
#   - LISP
#     - Very familiar style of configuring things
#   - LCO
#     - LCO == Letter Class Option filess
#     - LCO files are TeX
#     - They are included in the generated TeX source code from the letter
#     - Gives *full* access to KOMA-Script
#       - Big deal, because not everything is exposed through ORG or LISP
#       - Also gives full access to any and all TeX and LaTeX code
#     - LCO files are a KOMA-Script thing, so they are a LaTeX thing
#     -
#       #+begin_quote
#       Letter metadata set in LCO files overwrites letter metadata set in Emacs
#       variables but not letter metadata set in the Org file.
#       #+end_quote
#     - When you include multiple LCO files, they are evaluted LIFO. Properties
#       are set as they first appear, and are not set again. Say you include
#       "MyGeneralStuffForAnyLetter.lco" and then include
#       "MyStuffSpecificToThisLetter.lco". The specific stuff will get set first.
#       Then general stuff will get set last.
#       - Surely there is a better way to phrase this. I will work on that.
# - Recommendations
#   - What is the easiest way to starat using KOMA-Script based on what you know
#     today?
#   - If you don't know any of the approaches
#     - Then choose between learning LaTeX and Org
#   - If you only know LaTeX
#     - Then you will use the LTX/LCO metadata approach
#   - If you only know ORG
#     - Then you will use the ORG metadata approach
#   - If you only know ORG and LISP
#     - Then you will use the LISP approach for general metadata and the ORG
#       approach specific metadata
#   - If you know LTX/LCO, ORG, and LISP
#     - Then you have total flexibility
#     - The fact is that
#       - ORG settings always trump LTX/LCO and LISP
#       - LISP settings are a subset of all of the settings available in
#         KOMA-Script, so you will always have to fall back to LTX/LCO if you want
#         to use unexposed features
#       - LCO files are just plain old LaTeX, which you already know
#     - So the best thing to do
#       - Is to use ORG for letter-specific settings
#       - And LTX for general settings
#       - Everything is a lot simpler this way because
#         - One less metadata approach to keep track of
#         - All KOMA-Script features are present
#         - Need to learn details of KOMA-Script package anyway

# Configure the default class.

# [[https://tex.stackexchange.com/questions/102922/how-can-i-get-us-letter-output-from-koma-scripts-scrlttr2-class][This]] post explains how to default the US letter size. That is the likely default
# for my printed correspondence.

# #+BEGIN_SRC emacs-lisp
# (eval-after-load 'ox-koma-letter
#   '(progn
#      (add-to-list 'org-latex-classes
#                   '("my-letter"
#                     "\\documentclass[paper=letter, pagesize, fontsize=10pt, parskip]{scrlttr2}
# \\usepackage[english]{babel}
# \\usepackage[osf]{mathpazo}"))

#      (setq org-koma-letter-default-class "my-letter")))
# #+END_SRC

# There are two formats for the letters: [[http://orgmode.org/w/?p%3Dworg.git%3Ba%3Dblob%3Bf%3Dexporters/koma-letter-new-example.org%3Bh%3D180a9a0e10dd8f7483a67946daf36732c316f821%3Bhb%3D180a9a0e10dd8f7483a67946daf36732c316f821][heading-based]] and [[http://orgmode.org/w/?p%3Dworg.git%3Ba%3Dblob%3Bf%3Dexporters/koma-letter-example.org%3Bh%3De21b8b00c3e895be9dd573d02ea84b08796296a3%3Bhb%3De21b8b00c3e895be9dd573d02ea84b08796296a3][property-based]].

# Set up my default LCO files.

# #+BEGIN_SRC emacs-lisp
# (setq org-koma-letter-class-option-file "UScommercial9 KomaDefault")
# #+END_SRC

# **** ispell

# Doing literate programming a *lot*… it is a hassle to spell-check source blocks,
# so don't. Actually, there are lots of things that I probably don't want to check
# and this list is growing. All of the entries are explained here.

# Never ispell org source blocks:
# #+BEGIN_SRC emacs-lisp
# (add-to-list 'ispell-skip-region-alist '("^#\\+begin_src ". "#\\+end_src$"))
# #+END_SRC

# Never ispell org source blocks defined in upper case:
# #+BEGIN_SRC emacs-lisp
# (add-to-list 'ispell-skip-region-alist '("^#\\+BEGIN_SRC ". "#\\+#+END_SRC$"))
# #+END_SRC

# Never ispell org example blocks:
# #+BEGIN_SRC emacs-lisp
# (add-to-list 'ispell-skip-region-alist '("^#\\+begin_example ". "#\\+end_example$"))
# (add-to-list 'ispell-skip-region-alist '("^#\\+BEGIN_EXAMPLE ". "#\\+END_EXAMPLE$"))
# #+END_SRC

# Properties block in org do not need to be ispelled
# #+BEGIN_SRC emacs-lisp
# (add-to-list 'ispell-skip-region-alist '("\:PROPERTIES\:$" . "\:END\:$"))
# #+END_SRC

# Footnotes in org should not be ispelled:
# #+BEGIN_SRC emacs-lisp
# (add-to-list 'ispell-skip-region-alist '("\\[fn:.+:" . "\\]"))
# #+END_SRC

# Footnoes in org that have http links that are line breaked should not be
# ispelled:
# #+BEGIN_SRC emacs-lisp
# (add-to-list 'ispell-skip-region-alist '("^http" . "\\]"))
# #+END_SRC

# Verbatim regions in org mode should not be ispelled:
# #+BEGIN_SRC emacs-lisp
# (add-to-list 'ispell-skip-region-alist '("=.*" . ".*="))
# #+END_SRC

# In org I often use bold text in lists, and they should never be ispelled because
# they are usually abbreviations or other non-words:
# #+BEGIN_SRC emacs-lisp
# (add-to-list 'ispell-skip-region-alist '("- \\*.+" . ".*\\*: "))
# #+END_SRC

# Most of the default org export properties should be ignored because they are not
# words and I may ispell them manually when desired:
# #+BEGIN_SRC emacs-lisp
# (let (void)
#   (--each
#       '("ATTR_LATEX"
#         "AUTHOR"
#         "CREATOR"
#         "DATE"
#         "DESCRIPTION"
#         "EMAIL"
#         "EXCLUDE_TAGS"
#         "HTML_CONTAINER"
#         "HTML_DOCTYPE"
#         "HTML_HEAD"
#         "HTML_HEAD_EXTRA"
#         "HTML_LINK_HOME"
#         "HTML_LINK_UP"
#         "HTML_MATHJAX"
#         "INFOJS_OPT"
#         "KEYWORDS"
#         "LANGUAGE"
#         "LATEX_CLASS"
#         "LATEX_CLASS_OPTIONS"
#         "LATEX_HEADER"
#         "LATEX_HEADER_EXTRA"
#         "OPTIONS"
#         "SELECT_TAGS"
#         "STARTUP"
#         "TITLE")
#     (gcr/ispell-a2isra (gcr/ispell-org-header-lines-regexp it))))
# #+END_SRC

# **** Hooks

# Configure =org= mode hooks to make it easy to do the most commonly performed
# operations.

# Bit of a mystery that I couldn't =local-set-key= with one particular binding.
# Found a way that /does/ work with the help of Jorge and Peak. I'm OK with it
# remaining a mystery for now.

# #+BEGIN_SRC emacs-lisp
# (define-key org-mode-map (kbd "C-,") (lambda () (interactive) (insert " \\larr ")))
# #+END_SRC

# Started questioning why after hitting RETURN while in lists I have to hit TAB to
# get indented properly. Kind of a dead giveaway that I should be
# return-and-indenting! Looked at =org-return= to find that it has an argument
# about indenting and then saw that =org-return-indent= passes it for you. With that
# in mind, RETURN is bound to that now. Now ALEC has four different kinds of
# "returns" in Org in order of likelihood of usage:
# - org-return-indent :: Make it really easy to work in existing list items,
#   headings, and tables
#   - This is listed first because I often go back to modify entries
#   - <return> because it is used the most
# - org-meta-return :: Make it really easy to add new list items, headings, and
#   table contents
#   - M-<return> because the binding comes with Org
# - electric-indent-just-newline :: For when I want to break out of the default
#   Org indentation to start working at the beginning of the line for example when
#   I'm done working in a list or have just created a new heading
#   - C-M-<return> because it is next step "lower" in the binding
# - gcr/smart-open-line :: When I want to insert a new line between the current
#   and next line then position the cursor correctly indented at the start of it.
#   - s-<return> because it is that is the last place in the modifier key chain

#+BEGIN_SRC emacs-lisp
(defun gcr/org-mode-hook ()
  (local-set-key (kbd "C-;") 'gcr/vc-next-action)
  ;; (local-set-key (kbd "<return>") 'org-return-indent)
  ;; (local-set-key (kbd "C-M-<return>") 'electric-indent-just-newline)
  (local-set-key (kbd "C-1") 'org-narrow-to-subtree)
  (local-set-key (kbd "M-1") 'widen)
  ;; (local-set-key (kbd "C-2") 'gcr/org-edit-src-code-plus-name)
  (local-set-key (kbd "C-3") 'org-table-edit-field)
  (local-set-key (kbd "s-h") 'org-babel-check-src-block)
  (local-set-key (kbd "s-i i") 'org-babel-insert-header-arg)
  ;; (local-set-key (kbd "s-j") 'org-babel-previous-src-block)
  ;; (local-set-key (kbd "s-k") 'org-babel-next-src-block)
  ;; (local-set-key (kbd "s-l") 'org-babel-demarcate-block)
  ;; (local-set-key (kbd "s-;") 'org-babel-view-src-block-info)
  (local-set-key (kbd "s-b x") 'org-babel-expand-src-block)
  (local-set-key (kbd "s-b s") 'org-babel-switch-to-session)
  (local-set-key (kbd "s-b c") 'org-babel-switch-to-session-with-code)
  ;; (local-set-key (kbd "s-o") 'org-babel-execute-maybe)
  ;; (local-set-key (kbd "s-t") 'org-babel-tangle)
  (local-set-key (kbd "s-x") 'org-babel-do-key-sequence-in-edit-buffer)
  (local-set-key (kbd "s-w w") 'org-export-dispatch)
  (local-set-key (kbd "s-<f5>") 'org-babel-execute-buffer)
  (local-set-key (kbd "s-i d") 'org-display-inline-images)
  (local-set-key (kbd "s-i r") 'org-remove-inline-images)
  (local-set-key (kbd "C-.") (lambda () (interactive) (insert " \\rarr ")))
  (local-set-key (kbd "$") 'yf/org-electric-dollar)
  (when (and (fboundp 'guide-key-mode) guide-key-mode)
    (guide-key/add-local-guide-key-sequence "C-c")
    (guide-key/add-local-guide-key-sequence "C-c C-x")
    (guide-key/add-local-highlight-command-regexp "org-"))
  (fci-mode)
  (gcr/untabify-buffer-hook)
  (turn-on-stripe-table-mode)
  (linum-mode)
  (wrap-region-mode t))

(add-hook 'org-mode-hook 'gcr/org-mode-hook)
#+END_SRC

# Configure the =org= =babel= source code editing buffer with a key to make it
# easy to exit. This is consistent with the approach of "same to exit as enter".

# #+BEGIN_SRC emacs-lisp
# (defun gcr/org-src-mode-hook ()
#   (local-set-key (kbd "C-2") 'org-edit-src-exit)
#   (visual-line-mode))

# (add-hook 'org-src-mode-hook 'gcr/org-src-mode-hook)
# #+END_SRC

# ** Keyboard

# Echo keystrokes immediately:
# #+BEGIN_SRC emacs-lisp
# (setq echo-keystrokes 0.02)
# #+END_SRC

# * Keybindings
#   :PROPERTIES:
#   :noweb-ref: Keybindings
#   :END:

# Key-Chord [fn:93a799cf: http://melpa.org/#/key-chord] everything. It's
# documentation gives /the/ tip: keep chords limited to two fingers on the same hand
# if you can. I'll expand on this to use two hands, intionally, to specify the
# urgency of the operation about to be performed. The package /just works/ exactly
# as you would expect, and it is delightful. It is really fast, too. I tried out
# Key-Combo [fn:6f1e75f8: https://github.com/uk-ar/key-combo] and it seems really
# great. I just couldn't get it working quickly though, so I didn't try migrating
# beyond the hour or two that I invested.

# Think of Key-Chord as letting you add modifier keys *anywhere* and *anyhow* you want
# (be open minded here). Be pretty careful in chord specification though. My rough
# approach is:

# - *CLOSE* (continuity keys)
#   - Use alphanumeric/symbol key-chords when
#   - The combination is obvious… like ".." \rarr "…"
#   - There is *no* chance that it could inadvertently be pressed; recalling that
#     /both/ directions must be considered
#   - Excluding alphanumeric leaves; =` - = [ ] \ ; ' , . /=
#   - Likely offenders: =- = ; ' , .=
#   - Leaving: =` [ ] \ /=
#   - Left hand: 12x5
#   - Right hand only: 7x5
#   - 95 possible if this is right
#   - Preferences: [, ], \…
#   - Likelihood of usage? low
#     - Choosing a global mapping that works in all modes will involve a lot of
#       work
#     - Tough to choose these when =META= keys are easily within reach instead
#   - Vowels are the biggie, don't use them ever
#   - Surprise: n is turning out to be a big one that I can't use
#     - It seems very common in words that I use!
#     - Does it make sense to analyze all of my emails to see what the ones that
#       *I* shouldn't use?
# - *NEAR*
#   - Goal is to minimize finger travel
#   - Keys used most frequently
#   - In order of preference:
#   - C-#keys :: 10
#   - C-F keys :: 6 (3 easily in reach on one hand)
# - *FAR* (discontinuity keys)
#   - Super:any-one :: (12+10+11+26)=59
# - *FURTHER*
#   - Use =[S|C|M|S]F:5+= keys :: 8x4=32 bindings

# #+BEGIN_SRC emacs-lisp
# (require 'key-chord)
# (key-chord-mode 1)
# (setq key-chord-two-keys-delay 0.1)
# #+END_SRC

# =M-x= truly is the Emacs command line [fn:d0a5f045: https://aaronhawley.livejournal.com/28413.html].

# Sometimes you want to temporarily bind keys. Haven't much of a need yet myself,
# but when the time comes, this [fn:685d5985: https://github.com/abo-abo/centimacro]
# looks like a great option to have.

# Generally disallow stomping of global key-mappings unless it makes sense to me
# (thank you Stefan Monnier for pointing out that referencing the map variable
# is all it takes). For some reason, =execute-extended-command= has to be listed
# twice otherwise unstomping it doesn't work correctly. More investment needed.
# #+BEGIN_SRC emacs-lisp
# (defadvice global-set-key (before before-global-set-key activate)
#   (let* ((key (ad-get-arg 0))
#          (new-command (ad-get-arg 1))
#          (old-command (lookup-key global-map key)))
#     (when
#         (and
#          old-command
#          (not (equal old-command new-command))
#          (not (equal old-command 'digit-argument))
#          (not (equal old-command 'negative-argument))
#          (not (equal old-command 'ns-print-buffer))
#          (not (equal old-command 'move-beginning-of-line))
#          (not (equal old-command 'execute-extended-command))
#          (not (equal new-command 'execute-extended-command))
#          (not (equal old-command 'ns-prev-frame))
#          (not (equal old-command 'ns-next-frame))
#          (not (equal old-command 'mwheel-scroll))
#          (not (equal new-command 'diff-hl-mode))
#          (not (equal new-command 'my-eval-expression))
#          (not (equal old-command 'list-buffers))
#          (not (equal new-command 'gcr/vc-map))
#          )
#       (warn "Just stomped the global-map binding for %S, replaced %S with %S"
#             key old-command new-command))))
# #+END_SRC


# These key-bindings are custom for me and I've been using them for so long, and
# that makes it rig+1ht. There are always opportunities for improvement, though.
# Recently it dawned on me that it is poor-form to waste 3 function keys on
# the same task, so I rebound =F1= to different modifiers that I hope are
# consistent, and free up space, too. My preference is to leave =F5=, =F6, and
# =F7= generally unbound and available for similar operations that are performed
# in most programming modes. For example, =F5= will execute code in any Lisp-like
# environment.

# F10-F12 should be left alone:
# - F10 is used by Emacs
# - F11 is hide screen in OSX
# - F12 is dashboard and I want to give it a try

# Guide:
# - NON-DISRUPTIVE :: hands on home, no finger strain, C-[(2|3)|(9|0)]
# - SLIGHTLY-DISRUPTIVE :: hands on home, slight finger strain, C-[1|-]
# - DISRUPTIVE :: hands on keyboard, not home, palms are home
# - VERY-DISRUPTIVE :: hands on keyboard, not home, palms are moved from home

# ** NON-DISRUPTIVE

# Easily select regions:
# #+BEGIN_SRC emacs-lisp
# (global-set-key (kbd "C-'") 'er/expand-region)
# #+END_SRC

# ace-jumping is frequent, too, and this one is perfect all home keys same,
# dominant strong hand:
# #+BEGIN_SRC emacs-lisp
# (key-chord-define-global "df" 'ace-jump-mode)
# #+END_SRC

# Using =ace-jump= will introduce a new idea to you of easily jumping around
# within a buffer. From you, from wherever you jump /to/, you need jump /back/.
# Make it really really easy to do so.
# #+BEGIN_SRC emacs-lisp
# (key-chord-define-global "DF" 'ace-jump-mode-pop-mark)
# #+END_SRC

# multiple cursor mode… I kept these together because until I make an image, it
# would be too confusing to keep them in the non and slightly disruptive sections,
# as they are clearly that:
# #+BEGIN_SRC emacs-lisp
# (global-set-key (kbd "M-9") 'mc/edit-lines)
# (global-set-key (kbd "M-0") 'mc/mark-next-like-this)
# (global-set-key (kbd "M--") 'mc/mark-all-like-this)
# (global-set-key (kbd "M-8") 'mc/mark-previous-like-this)
# #+END_SRC

# ace-window is frequent, is beginning to adhere to a pattern of dual approaches:
# #+BEGIN_SRC emacs-lisp
# (key-chord-define-global "nm" 'ace-window)
# #+END_SRC

# Save 3 bytes:
# #+BEGIN_SRC emacs-lisp
# (key-chord-define-global "3." 'gcr/insert-ellipsis)
# #+END_SRC

# Indent with spaces for the likely scenario:
# #+BEGIN_SRC emacs-lisp
# (key-chord-define-global "4 " (lambda () (interactive) (insert "    ")))
# #+END_SRC

# German umlauts for a, o, and u:
# #+BEGIN_SRC emacs-lisp
# (key-chord-define-global (concat "A" "{") (lambda () (interactive) (insert "ä")))
# (key-chord-define-global (concat "A" "}") (lambda () (interactive) (insert "Ä")))
# (key-chord-define-global (concat "O" "{") (lambda () (interactive) (insert "ö")))
# (key-chord-define-global (concat "O" "}") (lambda () (interactive) (insert "Ö")))
# (key-chord-define-global (concat "U" "{") (lambda () (interactive) (insert "ü")))
# (key-chord-define-global (concat "U" "}") (lambda () (interactive) (insert "Ü")))
# #+END_SRC

# Arrows, so many:
# #+BEGIN_SRC emacs-lisp
# (global-set-key (kbd "C-,") (lambda () (interactive) (insert "←")))
# (global-set-key (kbd "C-.") (lambda () (interactive) (insert "→")))
# #+END_SRC

# Nice for UML, and French?
# #+BEGIN_SRC emacs-lisp
# (key-chord-define-global "<<" (lambda () (interactive) (insert "«")))
# (key-chord-define-global ">>" (lambda () (interactive) (insert "»")))
# #+END_SRC

# It is great to =ace-jump= to things. How about making deletions of contiguous text
# as easy and fast?! This library will makes deletes blazingly fast! Interesting
# tha I set up a 1:3 and 1:4 binding here; I am just starting to develop ideas
# about finger strength and usage.
# #+BEGIN_SRC emacs-lisp
# (key-chord-define-global "jl" 'ace-jump-zap-up-to-char)
# (key-chord-define-global "j;" 'ace-jump-zap-to-char)
# #+END_SRC

# I call stuff by name all the time. This should be a first-class call:

# smex integration points:
# #+BEGIN_SRC emacs-lisp
# (global-set-key (kbd "M-x") 'smex)
# (key-chord-define-global "jk" 'smex)
# (global-set-key (kbd "M-X") 'smex-major-mode-commands)
# (key-chord-define-global "FG" 'smex-major-mode-commands)
# #+END_SRC

# Open tons of files:
# #+BEGIN_SRC emacs-lisp
# (key-chord-define-global "nj" 'ido-find-file)
# #+END_SRC

# Open files in this project:
# #+BEGIN_SRC emacs-lisp
# (key-chord-define-global "bh" 'projectile-find-file)
# #+END_SRC

# Jumping to lines actually happens a lot. When you look at this layout, remember,
# or rather consider, that what you jump to, or navigate to, is layered in the
# sense that the granularity of your actions changes and all actions provided here
# are helpful for those different situations. This used to be =kc-df= but I typed
# =df= for data.frame so I had to change it, as well as the following which used to
# be =cv=. That wasn't good either because it is a painful reach. I need to document
# the lessons learned above. df-jk make so much more sense, though, and I came
# back to this to recall why I made this choice. This is an exploration question
# again because the simplicity and symmettry of df-jk is simpler. I am going to
# try using shift as a modifier key in the key-chord space. I'll use capital
# letters. Upon typing that I realized that I don't like this idea, it takes this
# binding from a non-disruptive to slightly-disruptive. I'll leave this alone
# again.
# #+BEGIN_SRC emacs-lisp
# (key-chord-define-global "dc" 'goto-line)
# #+END_SRC

# In the same spirit of poppping the mark with =ace-jump=, follow a similar appraoch
# for =goto-line=.
# #+BEGIN_SRC emacs-lisp
# (key-chord-define-global "DC" 'pop-to-mark-command)
# #+END_SRC

# Do nearly a =IKJL= style up/down/left/right arrow key, using using chords, saves a
# trip.

# You might wonder why I would use this when ace-jump-window is available? Good
# question. Sometimes you know exactly what buffer you want, so jump to it, and
# sometimes you just don't, and that is when you do it this way:
# #+BEGIN_SRC emacs-lisp
# (key-chord-define-global "JK" (lambda () (interactive) (other-window 1)))
# (key-chord-define-global "KL" (lambda () (interactive) (next-buffer)))
# (key-chord-define-global "L:" (lambda () (interactive) (previous-buffer)))
# #+END_SRC

# Web-searches occur quite frequently once you've a nice work-flow established.
# The keys in that mode are:
# - w :: word
# - s :: symbol
# - l :: line
# - r :: region
# #+BEGIN_SRC emacs-lisp
# (key-chord-define-global "gt" 'google-this-mode-submap)
# #+END_SRC

# These actions appear in order of importance, and thus frequency of use

# Do the /right thing/ for getting to the start of the line!
# #+BEGIN_SRC emacs-lisp
# (global-set-key (kbd "C-a") 'beginning-of-line-dwim)
# #+END_SRC

# I use VC quite frequently. This is easy to reach, and does what must be done:
# #+BEGIN_SRC emacs-lisp
# (global-set-key (kbd "C-;") 'gcr/vc-next-action)
# #+END_SRC

# Check =git= status:
# #+BEGIN_SRC emacs-lisp
# (global-set-key (kbd "C-M-;") 'magit-status)
# #+END_SRC

# You don't moves lines or regions a ton, but when you do, you usually can't use
# the arrow keys per mode, so use chords instead.
# #+BEGIN_SRC emacs-lisp
# (key-chord-define-global "yu" 'move-text-up)
# (key-chord-define-global "hj" 'move-text-down)
# #+END_SRC

# Now that =ispell= is configured nicely, I use it /all/ the time. Make that easy.
# First tried "is" for "ispell". Loved it. Then remembered that it is a common
# key combination. Forehead smack!

# #+BEGIN_SRC emacs-lisp
# (key-chord-define-global "qp" 'ispell)
# (key-chord-define-global "qo" 'ispell-word)
# #+END_SRC

# W for Writegood.

# #+BEGIN_SRC emacs-lisp
# (key-chord-define-global "wm" 'writegood-mode)
# (key-chord-define-global "wl" 'writegood-grade-level)
# (key-chord-define-global "wz" 'writegood-reading-ease)
# #+END_SRC

# Use the default Langtool bindings.
# #+BEGIN_SRC emacs-lisp
# (define-prefix-command 'gcr/langtool-map)
# (key-chord-define-global "qk" 'gcr/langtool-map)
# (define-key gcr/langtool-map "c" 'langtool-check-buffer)
# (define-key gcr/langtool-map "C" 'langtool-correct-buffer)
# (define-key gcr/langtool-map "j" 'langtool-goto-previous-error)
# (define-key gcr/langtool-map "k" 'langtool-show-message-at-point)
# (define-key gcr/langtool-map "l" 'langtool-goto-next-error)
# (define-key gcr/langtool-map "q" 'langtool-check-done)
# #+END_SRC

# Easily browse URLs. Surely there is a more refind way. This is the first step.
# #+BEGIN_SRC emacs-lisp
# (key-chord-define-global "wm" 'writegood-mode)
# #+END_SRC

# Occur has 3 cases. I like to use it to explore the unknown.
# #+BEGIN_SRC emacs-lisp
# (global-set-key (kbd "M-s p") 'gcr/occur-dwim)
# #+END_SRC

# Comment and uncomment anything:
# #+BEGIN_SRC emacs-lisp
# (key-chord-define-global "qi" 'gcr/comment-or-uncomment)
# #+END_SRC

# Start NeoTree:
# #+BEGIN_SRC emacs-lisp
# (key-chord-define-global "f0" #'neotree-toggle)
# #+END_SRC

# Scroll the whole buffer by one line keeping the cursor with it.
# #+BEGIN_SRC emacs-lisp
# (global-set-key (kbd "M-n") (kbd "C-u 1 C-v"))
# (global-set-key (kbd "M-p") (kbd "C-u 1 M-v"))
# #+END_SRC

** YASnippet
  :PROPERTIES:
  :noweb-ref: Hacking-YASnippet
  :END:

- Enable everywhere
- Allow expansion to occur within fields
- Load HELP snippets
- Use Ido to handle user decisions

#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :ensure t
  :config
  (yas-global-mode t)
  (setq yas-triggers-in-field t)
  (defun help/yas-minor-mode-hook-fn ()
    "HELP customizations."
    (define-key yas-minor-mode-map (kbd "<tab>") nil)
    (define-key yas-minor-mode-map (kbd "TAB") nil)
    (define-key yas-minor-mode-map (kbd "s-t") 'yas-expand))
  (add-hook #'yas-minor-mode-hook #'help/yas-minor-mode-hook-fn)
  (add-to-list #'yas-snippet-dirs "~/src/help/yasnippet")
  (yas-reload-all)
  (setq yas-prompt-functions '(yas-ido-prompt))
  :diminish yas-minor-mode)
#+END_SRC

** Structured Query Language (SQL)
** (Publishing)
** TeX
  :PROPERTIES:
  :noweb-ref: Hacking-Publishing-TeX
  :END:

#+BEGIN_SRC emacs-lisp
(use-package tex-site
  :ensure auctex
  :config
  (eval-after-load "tex"
    '(define-key TeX-mode-map (kbd "C-c C-c") #'help/safb-TeX-command-master)))
#+END_SRC

Save style info. This doesn't control the buffer save.

#+BEGIN_SRC emacs-lisp
(setq TeX-auto-save t)
#+END_SRC

Parse on load.

#+BEGIN_SRC emacs-lisp
(setq TeX-parse-self t)
#+END_SRC

Parse on save.

#+BEGIN_SRC emacs-lisp
(setq TeX-auto-save t)
#+END_SRC

Use PDFTeX to generate both DVI and PDF files.

#+BEGIN_SRC emacs-lisp
(setq TeX-PDF-mode t)
(setq TeX-DVI-via-PDFTeX t)
#+END_SRC

Don't prompt every time you run =C-c C-c= about saving the file, instead, just
save it.

#+BEGIN_SRC emacs-lisp
(setq TeX-save-query nil)
#+END_SRC

Load LCO files with AucTeX.

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.lco?\\'" . TeX-latex-mode))
#+END_SRC

** (DevOps)
** Shell Script
** Make
** Vagrant

~ruby-mode~ supports =Vagrantfile= OOTB.

** (Diagram, UML, Workflow)
** Artist
  :PROPERTIES:
  :noweb-ref: Hacking-Artist
  :END:

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.asc" . artist-mode))
(add-to-list 'auto-mode-alist '("\\.art" . artist-mode))
(add-to-list 'auto-mode-alist '("\\.asc" . artist-mode))
#+END_SRC

** DITAA
  :PROPERTIES:
  :noweb-ref: Hacking-DITAA
  :END:

When a drop of water joins the ocean it becomes the ocean.

#+BEGIN_SRC ditaa :file "./image/ditaa-drop_in_the_ocean.png" :noweb-ref ignore :results output replace
+---------+
| cBLU    |
|         |
|    +----+
|    |cBLU|
|    |    |
+----+----+
#+END_SRC

#+NAME:
[[file:./image/ditaa-drop_in_the_ocean.png]]

#+BEGIN_SRC ditaa :file "./image/ditaa-not_a_sailboat.png" :noweb-ref ignore :results output replace
+----------+1       1…3+------+
| Sailboat +◆----------+ Mast |
+-----+----+           +------+
      ◆1
      |
      |             1…2+------+
      +----------------+ Hull |
                       +------+
      This is not a sailboat
#+END_SRC

#+NAME:
[[file:./image/ditaa-not_a_sailboat.png]]

#+BEGIN_SRC emacs-lisp
(defconst help/ditaa-jar (concat (getenv "EELIB") "/ditaa.jar"))
(setq org-ditaa-jar-path help/ditaa-jar)
#+END_SRC

** Graphviz
** PlantUML
  :PROPERTIES:
  :noweb-ref: Hacking-PlantUML
  :END:

#+BEGIN_SRC emacs-lisp
(use-package plantuml-mode
  :ensure t
  :init
  (defconst help/plantuml-jar (concat (getenv "EELIB") "/plantuml.jar"))
  (setq plantuml-jar-path help/plantuml-jar)
  :config
  (eval-after-load "ob-plantuml"
    (setq org-plantuml-jar-path help/plantuml-jar)))
#+END_SRC

*Sequence Diagram*

- Feature rich.
- Information rich.

#+BEGIN_SRC plantuml :file "./image/plantuml-sequence_diagram.png" :noweb-ref ignore :results output replace
Alice --> Bob: Authentication Request
Bob --> Alice: Authentication Response

Alice --> Bob: Another authentication Request
Alice <-- Bob: another authentication Response
#+END_SRC

#+NAME:
[[file:./image/plantuml-sequence_diagram.png]]

*Use Case Diagram*

- Actor variable aliasing feature.

#+BEGIN_SRC plantuml :file "./image/plantuml-use_case_diagram.png" :noweb-ref ignore :results output replace
left to right direction
skinparam packageStyle rect
actor customer
actor clerk
rectangle checkout {
customer -- (checkout)
(checkout) .> (payment) : include (help) .> (checkout) : extends (checkout) -- clerk
}
#+END_SRC

#+NAME:
[[file:./image/plantuml-use_case_diagram.png]]

*Class Diagram*

- Valuable for all sorts of ideas in addition to classes.
- =hide=, =show=, and =include= are mentioned.
  - Could be a great reuse mechanism combined with noweb and tangling.
- Spotted characters might be useful to indicating other things.
  - Example is data which is clearly a first-class citizen.
  - Six package visualization types.
  - Packaging vs. namespaceing.
  - Good support for splitting large images among output pages.

#+BEGIN_SRC plantuml :file "./image/plantuml-class_diagram.png" :noweb-ref ignore :results output replace
title This is not a sailboat
scale 200 width
Sailboat "1" *-- "1..3" Mast
Sailboat "1" *-- "1..3" Hull
#+END_SRC

#+NAME:
[[file:./image/plantuml-class_diagram.png]]

*Activity Diagram*

- May indicate top to bottom flow using =top=.
- May label arrows.
- May force arrow direction.
- if/else structure for branching.
- Partition construct.
- [[http://plantuml.sourceforge.net/activity2.html][New syntax]] with more examples.

#+BEGIN_SRC plantuml :file "./image/plantuml-activity_diagram.png" :noweb-ref ignore :results output replace
start
partition Initialization {
    :read config file;
    :init internal variable;
}
partition Running {
    :wait for user interaction;
    :print information;
}

stop
#+END_SRC

#+NAME:
[[file:./image/plantuml-activity_diagram.png]]

*Component Diagram*

- The names to define all of the diagram entity types.
- Identify "Modern UML".
- Good for summaries.

#+BEGIN_SRC plantuml :file "./image/plantuml-component_diagram.png" :noweb-ref ignore :results output replace
[First component]
[Another component]
() "First Interface"
() "Another interface" as Interf2
DataAccess - [First Component]
[First Component] ..> HTTP : use
#+END_SRC

#+NAME:
[[file:./image/plantuml-component_diagram.png]]

*State Diagram*

#+BEGIN_SRC plantuml :file "./image/plantuml-state_diagram.png" :noweb-ref ignore :results output replace
[*] --> State1
State1 --> [*]
State1 : this is a string State1 : this is another string
#+END_SRC

#+NAME:
[[file:./image/plantuml-state_diagram.png]]

*Object Diagram*

#+BEGIN_SRC plantuml :file "./image/plantuml-object_diagram.png" :noweb-ref ignore :results output replace
object Object01
object Object02
Object01 <|-- Object02
#+END_SRC

#+NAME:
[[file:./image/plantuml-object_diagram.png]]

- Commands.
  - Header and footer values.
  - Zoom level.
  - Creole markup for most text elements.
  - Lists and sub-lists.
  - Horizontal lines. Will appear in most containers.
  - Headings.
  - Plain old HTML.
  - Tables, LaTeX style.
  - Use [[https://useiconic.com/open][OpenIconic icons]] anywhere.

- Fonts and colors.
  - You can change just about everything.
  - You may nest definitions.
  - =monochrome true= option.
    - If you are printing
    - Or don't want color.

- Internationalization.
  - Full Unicode character support.
